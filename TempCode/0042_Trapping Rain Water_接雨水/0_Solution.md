# 42_Trapping Rain Water_接雨水(Hard)

## 解法一：单调栈 $O(n)$

1. 考虑每个位置左边和右边 **第一个** 比自身不低的矩形条，以及三个矩形条构成的 `U` 型，相当于对水的面积按 **行** 进行拆解。

2. 维护严格单调递减的单调栈。在每次检查栈顶要出栈时，`i` 为右边第一个比 `stk.top()` 不低的矩形，`stk.top()` 弹出栈顶，并将其记为 `last`。

3. 假设此时栈中仍然存在矩形，现在 `stk.top()`（弹栈后的栈顶）、`last` 与 `i` 三个位置构成一个 `U` 型，其中 `level` 位置代表 `U` 型的底部，此时可以计算出该 `U` 型所能接受的水的面积为
   $$
   (i - stk.top() - 1) * (min(height[stk.top()], height[i]) - height[last])
   $$

4. 最后当前矩形进栈。

**时间复杂度：**

- 每个元素最多进栈一次出栈一次，故只需要 $O(n)$ 的时间。

**空间复杂度：**

- 需要额外 $O(n)$ 的空间存储单调栈。

## 解法二：三次线性扫描 $O(n)$

1. 观察整个图形，考虑对水的面积按 **列** 进行拆解

2. 注意到，每个矩形条上方所能接受的水的高度，是由它左边 **最高的** 矩形，和右边 **最高的** 矩形决定的。
   - 具体地，假设第 **i** 个矩形条的高度为 `height[i]`，
   - 矩形条左边 **最高的** 矩形条的高度为 `left_max[i]`，
   - 右边 **最高的** 矩形条高度为 `right_max[i]`，
   - 则该矩形条上方能接受水的高度为 `min(left_max[i], right_max[i]) - height[i]`。

3. 需要分别从左向右扫描求 `left_max`，从右向左求 `right_max`，最后统计答案即可。

4. 注意特判 `n` 为 `0`。

**时间复杂度：**

- 三次线性扫描，故只需要 $O(n)$ 的时间。

**空间复杂度：**

- 需要额外 $O(n)$ 的空间记录每个位置左边最高的高度和右边最高的高度。

## 解法三：双指针 $O(n)$

- 为什么取两边的最高的柱子当中的最小值呢？因为一个桶能蓄多少水看短板（这里我们有两个板，一个长板，一个短板）。算法二就是把左边的最高的柱子找出来，把右边的最高的柱子也找出来，然后再取最小值，就算是找到了短板了。

- 可以使用双指针来优化上述操作。Two Pointer 的算法就是不用非要把两边的最高的柱子都找出来再找短板，可以直接找短板。

- 初始时 `i = 0, j = n - 1`，`left_max, right_max` 分别代表i指针左侧最大值，和j指针右侧最大值。如果 $height[i] < height[j]$，说明此时阻碍当前盛水的是左侧，所以我们将 `i` 指针右移。