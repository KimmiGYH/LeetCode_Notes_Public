# 406_M_Queue Reconstruction by Height_根据身高重建队列



题目大意：

这道题给了我们一个队列，队列中的每个元素是一个 pair，分别为身高和前面身高不低于当前身高的人的个数，让我们重新排列队列，使得每个 pair 的第二个参数都满足题意。



### 解法一：从高到低考虑

身高降序排列，人数升序排列。

首先来看一种超级简洁的方法，给队列先排个序，按照身高高的排前面，如果身高相同，则第二个数小的排前面。

```c++
sort(people.begin(), people.end(), [](vector<int>& a, vector<int>& b) {
    return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]);
});
```

```
原数组：			  [7,0], [4,4], [7,1], [5,0], [6,1], [5,2]

按身高排序：			 [7,0], [7,1], [6,1], [5,0], [5,2], [4,4]

身高相同时第二个数排前面：[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]
```

然后新建一个空的数组，遍历之前排好序的数组，然后根据每个元素的第二个数字，将其插入到 `res` 数组中对应的位置。



### 写法二：erase

下面这种解法跟解法一很相似，只不过没有使用额外空间，而是直接把位置不对的元素从原数组中删除，直接加入到正确的位置上。



### 解法二：从低到高考虑

https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode-sol/

```c++
sort(people.begin(), people.end(), [](const vector<int>& a, const vector<int>& b) {
	return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
});
```

```
原数组：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

从低到高排：[4,4], [5,2], [5,0], [6,1], [7,1], [7,0]
```



### 解法三：树状数组

