# 1673. Find the Most Competitive Subsequence_找出最具竞争力的子序列 (Medium)



## 解法一：单调栈 `O(n+k)`

- 这道题本质是一个经典的**单调栈**问题，找出特定长度的递增序列。也涉及到了贪心的思想。

- 所谓单调栈就是维护一个栈，该栈要么是单调递增的，要么是单调递减。本题我们要维护一个**单调递增的栈**，每当遍历到一个新的元素时，将该元素与栈顶元素比较，如果该元素小于栈顶元素，则弹出栈顶元素，直到与栈顶元素相等或大于栈顶元素即可。

- 维护条件 `(n - i) + stk.size() > k`，使得数组剩下的元素数量加上栈中元素数量之和大于 `k`，才可能删掉栈中元素。



##### 时间复杂度

遍历整个数组需要$O(n)$的时间；

维护单调栈最坏需要 `k` 次比较(清空)；

故总时间复杂度为 $O(n + k)$。



