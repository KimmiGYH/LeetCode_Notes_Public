# 645_Set Mismatch_错误的集合

## 解法一：位运算 $O(n)$

- 使用位运算，可以达到 $O(n)$ 的时间复杂度和 $O(1)$ 的空间复杂度。

- 重复的数字在数组中出现 $2$ 次，丢失的数字在数组中出现 $0$ 次，其余的每个数字在数组中出现 $1$ 次。由此可见，重复的数字和丢失的数字的出现次数的奇偶性相同，且和其余的每个数字的出现次数的奇偶性不同。

- 如果在数组的 $n$ 个数字后面再添加从 $1$ 到 $n$ 的每个数字，得到 $2n$ 个数字，则在 $2n$ 个数字中，重复的数字出现 $3$ 次，丢失的数字出现 $1$ 次，其余的每个数字出现 $2$ 次。

- 根据出现次数的奇偶性，可以使用分组异或运算求解。

### 分组异或：

- 用 $x$ 和 $y$ 分别表示重复的数字和丢失的数字。考虑上述 $2n$ 个数字的异或运算结果 $xor$，由于异或运算 $\oplus$ 满足交换律和结合律，且对任何数字 $a$ 都满足 $a \oplus a = 0$ 和 $0 \oplus a = a$，因此 $xor = x \oplus x \oplus x \oplus y = x \oplus y$，即 $x$ 和 $y$ 的异或运算的结果。

- 由于 $x \ne y$，因此 $xor \ne 0$，令 $lowbit = xor \And (-xor)$，则 $lowbit$ 为 $x$ 和 $y$ 的二进制表示中的最低不同位，可以用 $lowbit$ 区分 $x$ 和 $y$。

- 得到 $lowbit$ 之后，可以将上述 $2n$ 个数字分成两组，第一组的每个数字 $a$ 都满足 $a \And lowbit = 0$，第二组的每个数字 $b$ 都满足 $b \And lowbit = 0$。

- 创建两个变量 $num1$ 和 $num2$，初始值为 $0$，然后再次遍历上述 $2n$ 个数字，对于每个数字 $a$，如果 $a \And lowbit = 0$，则令 $num1 = num1 \oplus a$，否则令 $num2 = num2 \oplus a$。

- 遍历结束之后，$num1$ 为第一组的全部数字的异或结果，$num2$ 为第二组的全部数字的异或结果。由于同一个数字只可能出现在其中的一组，且除了 $x$ 和 $y$ 以外，每个数字一定在其中的一组出现 $2$ 次，因此 $num1$ 和 $num2$ 分别对应 $x$ 和 $y$ 中的一个数字，但是具体对应哪个数还未知。

- 为了知道 $num1$ 和 $num2$ 分别对应 $x$ 和 $y$ 中的哪一个数字，只需要再次遍历 $nums$ 即可。如果数组中存在元素等于 $num1$，则有 $x = num1$ 和 $y = num2$，否则有 $x = num2$ 和 $y = num1$。

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $nums$ 的长度。整个过程需要对数组 $nums$ 遍历 $3$ 次，以及遍历从 $1$ 到 $n$ 的每个数 $2$ 次。

- 空间复杂度：$O(1)$。只需要常数的额外空间。

## 解法二: 哈希表

重复的数字在数组中出现 $2$ 次，丢失的数字在数组中出现 $0$ 次，其余的每个数字在数组中出现 $1$ 次。因此可以使用哈希表记录每个元素在数组中出现的次数，然后遍历从 $1$ 到 $n$ 的每个数字，分别找到出现 $2$ 次和出现 $0$ 次的数字，即为重复的数字和丢失的数字。

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $nums$ 的长度。需要遍历数组并填入哈希表，然后遍历从 $1$ 到 $n$ 的每个数寻找错误的集合。
- 空间复杂度：$O(n)$，其中 $n$ 是数组 $nums$ 的长度。需要创建大小为 $O(n)$ 的哈希表。

## 解法三:cpp_3_原地取相反数

```
1 2 3 3 ... n
1~n
比如当前数为 x，将其取反 nums[x] = -nums[x]
```

- 省去开判重数组的空间，用原地算法，将数组里的数取相反数
- 如果出现一次，将原数组里对应的数取反
- 通过看每个位置的数是正还是负，来判断这个数出现多少次
- 如果 $nums[x]$ 出现了一次，则是负数; 如果 $nums[x]$ 是正数，则可能出现两次或者一次都没出现
- 如何区分是出现两次还是出现零次?
- 先找出现两次的数，看 $x$ 取反之前是正数还是负数? 如果取反之前是负数，则说明已经有一次了，则当前 $x$ 出现了第二次.
- 另外一个是正数的数则出现零次，再遍历一下就能找出来。


