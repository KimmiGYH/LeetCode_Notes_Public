# 969_Pancake Sorting_煎饼排序

## 解法一：数组+双指针+选择排序

**煎饼排序**。这个排序方式很有意思，每次可以把前 $k$ 个数字进行翻转，问翻转多少次之后可以达到有序状态。

就像一摞煎饼一样，每次能把铲子插入煎饼中的某个位置，然后把铲子之上的煎饼都翻转一下，问如何在一系列反转能使所有煎饼是排序的。

![煎饼排序](https://pic.leetcode-cn.com/1645234396-UYFugs-image.png)

**解题方法**

**重要思路：我们把后面的数字先排好序，这样再翻转前面的时候就不会影响到后面。**

所以，先把最大的数字放到最后，然后再把次大的位置放在倒数第二个位置……
​

如何把最大的数字放到最后呢？**一个很简单的想法就是先把它翻转到第一个位置上去！**

所以，思路很清晰了：

1. 每次找到还没排序的数字之中最大的数字的位置，把这个位置之前的数字翻转，这一步使得最大数字去了最前面；
2. 第二步，再次翻转，把最大位置翻到它应该在的位置上去。

![煎饼排序](https://pic.leetcode-cn.com/1645234439-xbTybz-969.%20%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F.001.png)

另外需要提醒大家，代码的结果和题目的序列是不一样的，但是提交可以通过。

![提交结果](https://pic.leetcode-cn.com/1645234456-jevmQo-image.png)

- 时间复杂度：$O(N^{2})$，其中 $N$ 是数组长度；
- 空间复杂度：$O(1)$。

**总结**
- 这就是冒泡排序或者选择排序的思想，学会基础理论知识，才能以不变应万变啊！

冒泡排序：
- 将整个数组分成有序的部分和无序的两个部分。有序的在右，无序的在左。
- 每次要使得无序部分最大的元素移动到有序部分第一个元素的左边。
- 移动的方法是：依次比较相邻的两个元素，如果前面的比后面的大，就交换他们的位置。这样，大的元素就像水里气泡一样不断往上浮。移动结束有序部分增加了一个元素。

```cpp
//冒泡排序
void BubbleSort(int a[], int size)
{
    for (int i = size - 1; i > 0; --i) {
        for (int j = 0; j < i; ++j)
            if (a[j] > a[j + 1]) {
                int tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
    }
}
```

```cpp
//选择排序
function SelectionSort(A, n) {
    for (int i = size - 1; i > 0; --i) {
        max_index = 0;
        for (int j = 0; j <= i; j++) {
            if (A[j] > A[max_index])
                max_index = j;
        }
        swap(A[i], A[max_index]);
    }
}
```

[【题解】图解煎饼排序](https://leetcode-cn.com/problems/pancake-sorting/solution/fu-xue-ming-zhu-tu-jie-jian-bing-pai-xu-jto8z/)