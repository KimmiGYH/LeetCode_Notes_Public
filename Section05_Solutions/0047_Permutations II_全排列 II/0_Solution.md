# 47. Permutations II_全排列 II



##### (回溯) $O(n!)$

由于有重复元素的存在，这道题的枚举顺序和 [46. Permutations](https://leetcode.com/problems/permutations/) 不同。

1. 先将所有数从小到大排序，这样相同的数会排在一起；

2. 从左到右依次枚举每个数，每次将它放在一个空位上；

3. 对于相同数，我们人为定序，进行剪枝以避免重复计算：

   ```c++
   // 如果不是第一个没有被用过的数的话 就continue
   // 注意:首先 i 要大于 0，因为如果 i = 0 的话，前面肯定没有数了
   
   if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) {
       continue;
   }
   ```

4. 不要忘记递归前和回溯时，对状态进行更新。



##### 时间复杂度分析

搜索树中最后一层共 $n!$ 个节点，前面所有层加一块的节点数量相比于最后一层节点数是无穷小量，可以忽略。且最后一层节点记录方案的计算量是 $O(n)$，所以总时间复杂度是 $O(n × n!)$。

