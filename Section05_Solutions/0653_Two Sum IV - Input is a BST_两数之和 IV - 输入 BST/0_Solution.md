# 653_Two Sum IV - Input is a BST_两数之和 IV - 输入 BST

## 解法一：BST二分搜索树的性质+中序遍历+双指针思路

- 利用 $BST$ 树排序节点，**二分搜索树按中序遍历得到的数组结果是从小到大排序的**
- 首先将所有节点顺序取出来，将排序好的二叉树变成一个线性的排好序的队列，然后从数组两端向中间寻找可以满足条件的搭配。

**复杂度分析**
- 时间复杂度：$O(n)$
  - 最坏情况相当于将所有节点遍历了两次，因此是 $O(n)$ 的复杂度。
- 空间复杂度：$O(n)$

## 解法二：BST+DFS+hashset

- 最简单的方法就是遍历整棵树，找出所有可能的组合，判断是否存在和为 $k$ 的一对节点。现在在此基础上做一些改进。

- 如果存在两个元素之和为 $k$，即 $x+y=k$，并且已知 $x$ 是树上一个节点的值，则只需判断树上是否存在一个值为 $y$ 的节点，使得 $y=k-x$。基于这种思想，在树的每个节点上遍历它的两棵子树（左子树和右子树），寻找另外一个匹配的数。在遍历过程中，将每个节点的值都放到一个 $hashset$ 中。

- 对于每个值为 $x$ 的节点，在 $hashset$ 中检查是否存在 `k - x->val`。如果存在，那么可以在该树上找到两个节点的和为 $k$；否则，将 `x->val` 放入到 $hashset$ 中。

- 如果遍历完整棵树都没有找到一对节点和为 $k$，那么该树上不存在两个和为 $k$ 的节点。

**复杂度分析**
- 时间复杂度：$O(n)$，其中 $n$ 是树中节点的数量。最坏的情况下，需要遍历整棵树。
- 空间复杂度：$O(n)$。最坏的情况下，$hashset$ 存储 $n$ 个节点的值。

## 解法三：BST+BFS+hashset

使用广度优先搜索查找一对节点和为 $k$ 的过程如下：
- 维护一个 $hashset$
- 将根节点加入 $queue$，然后执行以下步骤：

1. 从队列首部删除一个元素 $t$。
2. 检查 $hashset$ 中是否存在 `k - t->val`。如果存在，返回 $True$。
3. 否则，将 $t$ 加入 $hashset$。然后将当前节点的左孩子和右孩子加入 $queue$。
4. 重复步骤一至三，直到 $queue$ 为空。
5. 如果 $queue$ 为空，返回 $False$。

- 按照以上步骤，逐层遍历二叉树。

**复杂度分析**
- 时间复杂度：$O(n)$，其中 $n$ 是树中节点的数量。最坏的情况下，需要遍历整棵树。
- 空间复杂度：$O(n)$。最坏的情况下，$hashset$ 存储 $n$ 个节点的值。
