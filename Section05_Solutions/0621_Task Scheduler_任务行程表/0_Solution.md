# 621_Task Scheduler_任务行程表

**题目大意**：这道题让我们安排CPU的任务，规定在两个相同任务之间至少隔 `n` 个时间点。

## 解法一：贪心

由于题目中规定了两个相同任务之间至少隔n个时间点，那么我们首先应该处理的出现次数最多的那个任务，先确定好这些高频任务，然后再来安排那些低频任务。

**来看一个例子：**

`AAAABBBEEFFGG 3`

我们发现任务 `A` 出现了 $4$ 次，频率最高，于是我们在每个 `A` 中间加入三个空位，如下：

```
A---A---A---A

AB--AB--AB--A   (加入B)

ABE-ABE-AB--A   (加入E)

ABEFABE-ABF-A   (加入F，每次尽可能填满或者是均匀填充)

ABEFABEGABFGA   (加入G)
```

**再来看一个例子：**

`ACCCEEE 2`

我们发现任务 `C` 和 `E` 都出现了 $3$ 次，那么我们就将 `CE` 看作一个整体，在中间加入一个空位即可：

```
CE-CE-CE

CEACE-CE   (加入A)
```

- $mx$ 为最大出现次数，分成了 $(mx - 1)$ 再加上最后面的字母，其中 $mx$ 为最大出现次数。

- 例子1中，$A$ 出现了 $4$ 次，所以 `A---` 模块出现了 $3$ 次，再加上最后的 $A$，每个模块的长度为 $4$。

- 例子2中，`CE-` 出现了 $2$ 次，再加上最后的 `CE`，每个模块长度为 $3$。

**我们可以发现**：

- 模块的次数为任务最大次数减 $1$；
- 模块的长度，即每块中的个数为 $n + 1$；
- 最后加上的字母个数为出现次数最多的任务，可能有多个并列；

那么最后加上的字母个数为多少呢？还需要补全的个数是多少呢？

**用之前的例子来说明**：

`AAAABBBEEFFGG 3`

`A` 出现了 $4$ 次，最多，$mx=4$，那么可以分为 $mx-1=3$ 块，如下：

```
A---A---A---
```

每块有 $n+1=4$ 个，最后还要加上末尾的一个 `A`，也就是 $25-24=1$ 个任务，最终结果为 $13$：

```
ABEFABEGABFGA
```

**再来看另一个例子**：

`ACCCEEE 2`

`C` 和 `E` 都出现了 $3$ 次，最多，$mx=3$，那么可以分为 $mx-1=2$ 块，如下：

```
CE-CE-
```

每块有 $n+1=3$ 个，最后还要加上末尾的一个`CE`，也就是 $25-23=2$ 个任务，最终结果为 $8$：

```
CEACE-CE
```

好，那么此时你可能会有疑问，为啥还要跟原任务个数 `len` 相比，**取较大值**呢？我们再来看一个例子：

`AAABBB 0`

`A` 和 `B` 都出现了 $3$ 次，最多，$mx=3$，那么可以分为 $mx-1=2$ 块，如下：

`ABAB`

每块有 $n+1=1$ 个？
你会发现有问题，这里明明每块有两个啊，为啥这里算出来 $n+1=1$ 呢，因为给的 $n=0$，这有没有矛盾呢，没有！因为 `n` 表示相同的任务间需要间隔的个数，那么既然这里为 `0` 了，说明相同的任务可以放在一起，这里就没有任何限制了，我们只需要执行完所有的任务就可以了，所以我们最终的返回结果一定不能小于任务的总个数 `len` 的，这就是要对比取较大值的原因了。

## 解法二：Greedy

- **【思想】**：先算出所有空出来的位置，然后计算出所有需要填入的 $tasks$ 的个数；
如果超出了空位的个数，就需要最后再补上相应的个数。

- 注意这里如果有多个任务出现次数相同，那么将其整体放一起，就像上面的第二个例子中的 `CE` 一样，那么此时每个模块中的空位个数就是 $n + 1 - k$ （$k$ 为出现最大次数任务的个数）

- 空位的总数是模块数 $mx -1$ 乘以每个模块中空位的个数 $n + 1 - k$

- 除去已经放入模块中的，还剩下的 $tasksLeft$ 的个数就是 $task$ 的总个数 **减去** $mx * k$（最大次数 × 最大次数任务的个数）这样一个矩形，此时用 $tasksLeft$ 和之前求出的空位 $emptySlots$ 相比较，如果空位数要大于剩余的 $tasks$ 数，那么则说明还需要补充多于的空位，否则就直接返回 $tasks$ 的总数即可。

## 解法三：优先队列

- 思路是建立一个优先队列，然后把统计好的个数都存入优先队列中，那么大的次数会在队列的前面。
- 这题还是要**分块**，每块能装 $n+1$ 个任务，装任务是从优先队列中取，每个任务取一个，装到一个临时数组中，然后遍历取出的任务；
- 对于每个任务，将其哈希表映射的次数减 $1$，如果减 $1$ 后，次数仍大于 $0$，则将此任务次数再次排入队列中；
- 遍历完后如果队列不为空，说明该块全部被填满，则结果加上 $n+1$。
- 我们之前在队列中取任务是用个变量 $cnt$ 来记录取出任务的个数，我们想取出 $n+1$ 个，如果队列中任务数少于 $n+1$ 个，那就用 $cnt$ 来记录真实取出的个数，当队列为空时，就加上 $cnt$ 的个数。
