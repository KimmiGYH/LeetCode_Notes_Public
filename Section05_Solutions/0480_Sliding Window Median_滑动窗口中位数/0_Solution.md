# 480_滑动窗口中位数_Sliding Window Median (Hard)

## 解法一：对顶堆 $O(nlogk)$

1. 定义一个小根堆 `min_heap` 和一个大根堆 `max_heap`，小根堆的堆顶大于等于大根堆的堆顶。
2. 保证小根堆的大小比大根堆的大小**多** $1$ **或相等**。
3. 按照上述的定义，小根堆的堆顶或者两个堆的堆顶的平均值就是中位数。
4. 添加元素时，若小根堆为空或添加的元素大于等于小根堆堆顶，则添加进小根堆；否则添加到大根堆；
5. 添加后，若两个堆的大小不满足 2 中的要求，则进行调整。
6. 删除元素时，只需要在小根堆或大根堆删除一个等于该元素值的元素即可。
7. 由于此题涉及删除操作，所以堆的容器采用 $multiset$，方便操作。

- 用一个 $multiset$ 集合，我们首先将数组的前 $k$ 个数组加入集合中，由于 $multiset$ 自带排序功能，所以我们通过 $k/2$ 能快速地找到指向最中间的数字的迭代器 $mid$；

- 维护了 $left$ 和 $right$ 两个 $multiset$，分别保存有序数组的左半段和右半段的数字，保持 $right$ 的长度大于等于 $left$ 的长度。

- 我们开始遍历数组 $nums$，如果 $i >= k$，说明此时滑动窗口已经满 $k$ 个了
- `int x = nums[i], y = nums[i - k];` $x$ 是加入的数，$y$ 是删除的数

- 先处理插入 $x$ 和删除 $y$ 的操作：
  - 如果 $x$ 大于等于 $right$最小值，则将 $x$ 插入进 $right$，否则插入进 $left$；
  - 如果 $y$ 大于等于 $right$最小值，则将 $y$ 从 $right$ 中删掉，否则从 $left$ 中删掉；
    - 删的时候不要直接 `erase(y)`，这样会把所有的 $y$ 都删掉
    - 而应该用 `erase(right.find(y))`，这样会只删掉一个 $y$

- 再进行调整操作：
  - 如果左边元素比右边多，那么将左边最大值插到右边去；
  - 如果右边元素比左边多，那么将右边最小值插到左边去。

- 最后我们再计算中位数并加入结果 $res$ 中，根据 $k$ 的奇偶性来分别处理。

**时间复杂度：** 由于堆的大小最大为 $k$，在 $multiset$ 中添加或删除元素的时间复杂度为 $O(log⁡k)$，共需要操作 $n$ 次，故总时间复杂度为 $O(nlog⁡k)$。

**空间复杂度：** 需要额外 $O(n)$ 的空间存储堆。
