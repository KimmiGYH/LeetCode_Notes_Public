# 37. Sudoku Solver_解数独(Hard)

![sudoku](https://pic.leetcode-cn.com/2b141392e2a1811d0e8dfdf6279b1352e59fad0b3961908c6ff9412b6a7e7ccf-image.png)

## 解法一：DFS + 回溯

我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。

**思路**：最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为 $[1,9]$，而数组的下标从 $0$ 开始，因此在存储时，我们使用一个长度为 $9$ 的布尔类型的数组，其中 $i$ 个元素的值为 $True$，当且仅当数字 $i+1$ 出现过。例如我们用 $row[2][3]$ = $True$ 表示数字 $4$ 在第 $2$ 行已经出现过，那么当我们在遍历到第 $2$ 行的空白格时，就不能填入数字 $4$。

### 写法1：

- 预处理出`row`，`col`，`cell`数组，某些元素的位置已经被标识过；
- `dfs` 从 `(0,0)` 到 `(8,8)` 按顺序递归，假设递归到当前位置是`(x, y)`；
  - 若该位置已经有数字，则直接跳去下一个位置；
  - 若该位置没有数字，则往该位置尝试填 `1` 到 `9` 的数字，并在`row`，`col`，`cell `数组中进行标记，用完记得**恢复现场**；
- 当能成功到达最后一个位置，因为题干说只有唯一解，所以直接返回 `true`，表示找到答案，结束递归。

### 写法2：

对于子数独，可以使用二维数组记录映射，写成数组 $box[idx][t]$，公式为 `int idx = (i / 3) * 3 + j / 3;`


## 解法二：位运算

**思路**：在回溯的方法中，我们使用了长度为 $9$ 的二维数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一维数组表示每个数字是否出现过。

具体地，数 $b$ 的二进制表示的第 $i$ 位（从低到高，最低位为第 $0$ 位）为 $1$，当且仅当数字 $i+1$ 已经出现过。例如当 $b$ 的二进制表示为 $(011000100)_{2}$ 时，就表示数字 $3$，$7$，$8$ 已经出现过。

位运算有一些基础的使用技巧。下面列举了所有在代码中使用到的技巧：

- 对于第 $i$ 行第 $j$ 列，$row[i] \mid  col[j] \mid  box[\left \lfloor i/3 \right \rfloor ][\left \lfloor j/3 \right \rfloor ]$ 中，第 $k$ 位为 $1$，表示该位置不能填入数字 $k + 1$（因为已经出现过），其中 `|` 表示按位或运算。
  - 如果我们对这个值进行 `~` 按位取反运算，那么第 $k$ 位为 $1$ 就表示该位置可以天入数字 $k + 1$，我们就可以通过寻找 $1$ 来进行枚举。
  - 由于在进行按位取反运算后，这个数的高位也全部变成了 $1$（注意整型有32位，最高位1表示该数为负数），而这是我们不应当枚举到的，因此我们需要将这个数和 $(111111111)_{2} = (1EF)_{16}$ 进行按位运算 `&`，将所有无关的位设置为 $0$。

- 对于 flip 开关函数，使用了异或性质，使用按位异或运算 `^`，将第 $i$ 位从 $0$ 变为 $1$，或从 $1$ 变为 $0$。具体地，与数 $1 << t$ 进行按位异或运算即可，如 `row[i] ^= 1 << t;`

- $lowbit$ 可以用 `b & -b` 得到 $b$ 二进制表示中最低为的 $1$，这是因为 $-b$ 在计算机中以补码的形式存储，它等于 $\sim b + 1$。$b$ 和 $\sim b$ 进行按位与运算，那么会得到 $0$，但是 $\sim b$ 增加 $1$ 之后，最低位的连续的 $1$ 都变为 $0$，而最低位的 $0$ 变为 $1$，对应到 $b$ 中即为最低位的 $1$。因此当 $b$ 和 $\sim b + 1$ 进行按位与运算时，只有最低位的 $1$ 会被保留。 

- 当我们得到这个最低位的 $1$ 时，可以查看最低位 $1$ 后面有多少个 $0$，思路参考 461题汉明距离的思路。比如二进制 `1000` 有 3 个 $0$，将该数和 $1$ 异或，如果是 $0$ 异或结果为 $1$，将个数加起来，同时右移一位，直到遇到 $1$，异或结果为 $0$
  ```cpp
  1000
  0001
  ```

  ```cpp
      int zero_no(int& digitMask) {
        int cnt = 0;
        while (digitMask) {
            if (digitMask ^ 1) cnt ++;
            digitMask >>= 1;
        }
        return cnt;
    }
  ```

- 如何枚举二进制中的下一个 `1`？

  - 我们可以用 $b$ 和最低位的 $1$ 进行按位异或运算，就可以将其从 $b$ 中去除，这样就可以枚举下一个 $1$。
  ```cpp
  for (; 条件; b ^= b & -b) {
    //...;
    }
  ```

  - 同样地，我们也可以用 $b$ 和 $b−1$ 进行按位与运算达到相同的效果。
  ```cpp
  for (; 条件; b &= (b - 1)) {
    //...;
    }
  ```

## 解法三：位运算优化

我们可以顺着方法二的思路继续优化下去：

- 如果一个空白格只有唯一的数可以填入，也就是其对应的 $b$ 值和 $b-1$ 进行按位与运算后得到 $0$（即 $b$ 中只有一个二进制位为 $1$）。此时，我们就可以确定这个空白格填入的数，而不用等到递归时再去处理它。

这样一来，我们可以不断地对整个数独进行遍历，将可以唯一确定的空白格全部填入对应的数。随后我们再使用与方法二相同的方法对剩余无法唯一确定的空白格进行递归 + 回溯。
