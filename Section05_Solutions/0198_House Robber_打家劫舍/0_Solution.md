# 198 House Robber

## 方法一：暴力解法 记忆化搜索(较慢)

暴力解法：检查所有房子的组合，对每一个组合，检查是否有相邻的房子，如果没有，记录其价值。找最大值。`O((2^n)*n)`

注意其中对**状态**的定义：

考虑偷取 `[x...n-1]` 范围里的房子（函数的定义）

根据对状态的定义，决定**状态的转移**：

```cpp
f(0) = max{ v(0) + f(2), v(1) + f(3), v(2) + f(4), ..., 
                v(n-3) + f(n-1), v(n-2), v(n-1) }  //（状态转移方程）
```

## 方法二：动态规划 用两个数组来表示(较快)

看 **思路.png**

f(i) 表示 从 `1~i`中选，必选`i`
g(i) 表示 从 `1~i`中选，必不选`i`

f(i) 只有一种选择，`i`必选，所以看前面部分的`max`

前面部分相当于从`1 ~ i-1`中选，且必然不能选`i-1`，所以前面部分的最大值恰好是 `g(i-1)`

`w(i)`是第`i`个房子里可以偷的数量

`f(i) = g(i-1) + w(i)`

`g(i)` 有两种情况，选`i-1` 和 不选`i-1`

- 从 `1 ~ i-1`中选，且必然选 `i-1`：`f(i-1)`
- 从 `1 ~ i-1`中选，且必不选 `i-1`：`g(i-1)`
- 所以 `g(i) = max( f(i-1) , g(i-1) )`

## 方法三：动态规划 用一个数组来表示(较慢)

算法复杂度 `O((2^n))`

对状态的定义：

考虑偷取`[x...n-1]`范围里的房子（函数的定义）

改变对状态的定义：

考虑偷取`[0...x]`范围里的房子（函数的定义）

## 方法四：滚动数组 (较快)

DP优化辅助空间，把迭代的值保存在 2 个变量中

**复杂度分析**

时间复杂度：`O(n)`，其中 `n` 是数组长度。只需要对数组遍历一次。

空间复杂度：`O(1)`。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 `O(1)`。



## 方法五：模拟(较慢)

- `a` 对于偶数位上的最⼤值的记录
- `b` 对于奇数位上的最⼤值的记录
