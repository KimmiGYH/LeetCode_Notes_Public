# 304_Range Sum Query 2D - Immutable_二维区域和检索-矩阵不可变 (Medium)

## 解法一：二维前缀和 $O(n^{2})$

![二维前缀和.png](https://cdn.acwing.com/media/article/image/2021/02/09/41956_f77638706a-二维前缀和.png) 

1. $S[i,j]$ 即为图1 红框中所有数的和为：

    $S[i, \ j] = S[i, \ j-1] + S[i-1, \ j] - S[i-1, \ j-1] + matrix[i, \ j]$

2. $(x_{1},y_{1})$，$(x_{2},y_{2})$ 这一子矩阵中的所有数之和为：

    $S[x_{2}, \ y_{2}] - S[x_{1} - 1, \ y_{2}] - S[x_{2}, \ y_{1} - 1] + S[x_{1} - 1, \ y_{1} - 1]$

注意下标

**时间复杂度分析**：

- 初始化要遍历整个矩阵，时间复杂度是 $O(n^{2})$；计算矩形区域的和时只需要常数次计算，时间复杂度是 $O(1)$。

### 二维前缀和模板【重点】

下面重点分享下前缀和模板该如何记忆，其实很多模板都可以按照类似方式进行记忆。

虽然「二维前缀和」的模板相比「一维前缀和」的模板要长，但是逻辑是清晰的，可以现场推导。

当然也可以在理解的基础上，使用以下方式进行记忆：

```cpp
// 预处理前缀和数组
{
    sum.resize(n+1, vector<int>(m+1,0));
    // 预处理除前缀和数组（模板部分)
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            // 当前格子(和) = 上方的格子(和) + 左边的格子(和) - 左上角的格子(和) + 当前格子(值)【和是指对应的前缀和，值是指原数组中的值】
            sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + matrix[i-1][j-1];
        }
    }
}
    
// 首先我们要令左上角为 (x1, y1) 右下角为 (x2, y2)
// 计算 (x1, y1, x2, y2) 的结果
{
    // 前缀和是从 1 开始，原数组是从 0 开始，上来先将原数组坐标全部 +1，转换为前缀和坐标
    x1++; y1++; x2++; y2++;
    // 记作 22 - 12 - 21 + 11，然后 不减，减第一位，减第二位，减两位
    // 也可以记作 22 - 12(x - 1) - 21(y - 1) + 11(x y 都 - 1)
    ans = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1];

}
```
