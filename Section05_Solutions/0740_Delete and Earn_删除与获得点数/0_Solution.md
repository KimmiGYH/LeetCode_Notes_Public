# 740_Delete and Earn_删除与获得点数(Medium)

**题目大意**：给到一个数组，每次让我们删除一个数字，删除的数字本身变为了积分累积，并且要同时移除之前数的加1或减1的数，但此时移除的数字不累计积分，让我们求最多能获得多少积分。

## 解法一：动态规划

**思路**：这道题跟之前那道 198.House Robber 的本质是一样的，那道题小偷不能偷相邻的房子，这道题相邻的数字不能累加积分，是不是一个道理？

- $sums$ 数组建立了数字和其总积分的映射；
- 对于每一个数字，我们都有两个选择，拿或者不拿。
- 如果我们拿了当前的数字，我们就不能拿之前的数字（如果我们从小往大遍历就不需要考虑后面的数字），那么当前的积分就是不拿前面的数字的积分加上当前数字之和。
- 如果我们不拿当前的数字，那么对于前面的数字我们既可以拿也可以不拿，于是当前的积分就是拿前面的数字的积分和不拿前面数字的积分中的较大值。

- 状态表示：
  - f(i)表示遍历了 1~i 种数字，取当前数字和时的最大值；
  - g(i)表示遍历了 1~i 种数字，且不取当前数字和时的最大值；
- 状态属性：最大值

借用198.House Robbery那道题的思路图：
![思路](https://raw.githubusercontent.com/KimmiGYH/LeetCode_Notes_Public/master/Section05_Solutions/0198_House%20Robber_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/0_%E6%80%9D%E8%B7%AF.png)


- 状态转移方程分析：

  - $f(i)$ 只有一种选择，`i`必选，所以看前面部分的 $max$；
    - 前面部分相当于从`1 ~ i-1`中选，且必然不能选`i-1`，所以前面部分的最大值恰好是 $g(i-1)$；
    - `w(i)`是第`i`个数的积分综合 $sums[i]$
    - 所以 $f(i) = g(i-1) + sums[i]$

  - $g(i)$ 有两种情况，选`i-1` 和 不选`i-1`
    - 从 `1 ~ i-1` 中选，且必然选 `i-1`：$f(i-1)$
    - 从 `1 ~ i-1` 中选，且必不选 `i-1`：$g(i-1)$
    - 所以 $g(i) = max( f(i-1) , g(i-1) )$

## 解法二：动态规划 + 滚动数组思想

在上面题解的基础上，

- 这里我们用 $take$ 和 $skip$ 分别表示拿与不拿上一个数字，$takei$ 和 $skipi$分别表示拿与不拿当前数字；
- 每次更新完当前的 $takei$ 和 $skipi$ 时，也要更新 $take$ 和 $skip$，为下一个数字做准备，
- 最后只要返回 $take$ 和 $skip$ 中的较大值即可，

## 解法三：Optimal

这种解法直接使用 $sums$ 数组来更新，而没有使用额外的变量。

- $sums$ 实际上相当于建立了数字和其总积分的映射，这里的总积分的计算方法是由数字乘以其出现次数得来的。
- 于题目中说了每个数字不会超过 $10000$，所以 $sums$ 的长度可以初始化为$1e4+10$，然后遍历原数组，将遇到的数字都累加到该数字在数组中的位置上。
- 然后从 $sums$ 数组的第三个数字开始遍历，更新方法跟上面解法的思路很类似：
- 其实思想就是：在不拿当前数的积分，跟不拿前一个数的积分加上当前的积分之和，取二者中的较大值更新当前值 $sums[i]$
- 即当前的 $sums[i]$ 值就等于前一个值 $sums[i-1]$ 和前两个值 $sums[i-2]$ 加上当前的 $sums[i]$ 值中的较大值
