# 496_Next Greater Element I_下一个更大元素 I

## 解法一：单调栈 + 哈希表 $O(n + m)$

![单调栈](https://cdn.acwing.com/media/article/image/2022/01/28/41956_9f004d247f-%E5%8D%95%E8%B0%83%E6%A0%88.png)

- 当题目出现「找到最近一个比其大的元素」的字眼时，自然会想到「单调栈」。
- 规律：
  - 找到数组中左边第一个比其小的数，用↗升序单调栈
  - 找到数组中左边第一个比其大的数，用↘降序单调栈
- 现在我们的目标是在数组 $nums2$ 中找到右边第一个比其大的数，相当于逆序来看，找到左边第一个比其大的数。所以：逆序遍历 + 降序单调栈。
- 我们在遍历 $nums2$ 时，实时维护一个单调栈，当我们遍历到元素 $nums2[i]$ 时，可以先将栈顶中比 $nums2[i]$ 小的元素出栈，最终结果有两种可能：
  - (1) 栈为空，说明 $nums2[i]$ 之前（右边）没有比其大的数；
  - (2) 栈不为空， 此时栈顶元素为 $nums2[i]$ 在 $nums2$ 中（右边）最近的比其大的数。用 $vec$ 数组逆序记录这些数组。
- 使用哈希表记录每个 $nums2$ 中每个元素对应的下标 $i$，由于 $nums1$ 是 $nums2$ 的子集，就能找到 $nums1$ 在 $vec$ 中对应下标记录的值，这便是所要求的值，将它们加进答案数组即可。

**复杂度分析：**
- 时间复杂度：$O(m + n)$，其中 $m$ 是 $\textit{nums}_1$ 的长度，$n$ 是 $\textit{nums}_2$ 的长度。
  - 我们需要遍历 $\textit{nums}_2$ 以计算 $\textit{nums}_2$ 中每个元素右边的第一个更大的值；
  - 需要遍历 $\textit{nums}_1$ 以生成查询结果。

- 空间复杂度：$O(n)$，用于存储哈希表。

