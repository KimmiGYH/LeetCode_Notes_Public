# 1539. Kth Missing Positive Number_第 k 个缺失的正整数 (Easy)



## 解法一：哈希表



- 将所有元素保存至哈希表，检查 `1 ~ max(arr)`

- 举例：

  ```c++
  输入：arr = [2,3,4,7,11], k = 5
  输出：9
  解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
  ```

  (1) 先将 `arr` 存进 `unordered_set` 中：`st{2, 3, 4, 7, 11} `

  (2) `for (int i = 1; i <= arr.back(); ++i) ` ， `1 ~ 11` 中 不在 `set` 里的数有：1, 5, 6, 8, 9, 10

  | 循环    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
  | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **set** |      | 2    | 3    | 4    |      |      | 7    |      |      |      | 11   |

  (3) 可以看到第 `5` 个缺失的数是 `9`。当循环的数不在集合中，就 `--k` ，当 `k==0` 时，该数即为缺失的数。

- 举例：另一种情况

  当前面的数并不缺失时，如

  ```c++
  输入：arr = [5,6,7,8,9], k = 9
  输出：14
  解释：缺失的正整数包括 [1,2,3,4, 10,11,12,13,14] 。第 9 个缺失的正整数为 14 。
  ```

  那缺失的第 `9` 个数是 `arr.back() + k = 14` （注意此时 `k` 已经自减 4 次 到 `k = 5` 了）。



时间复杂度: $O(max(arr)) ~ O(1000)$

空间复杂度: $O(n)$





## 解法二：二分查找(索引)



查找大于等于 / 大于 `target` 的第一个元素（查找最小的 index `left` 使得 

```c++
arr[left] - (left + 1) >= k(target)
```

这说明们在 index `left` 的地方错过了至少 `k` 个数。



还是举上面的那个例子：

```cpp
输入：arr = [5,6,7,8,9], k = 9
输出：14
解释：缺失的正整数包括 [1,2,3,4, 10,11,12,13,14] 。第 9 个缺失的正整数为 14 。
```

在 `index = 0` 的地方 `arr[0] = 5`，前面错过了 `4` 个数

在 `index = 1` 的地方 `arr[1] = 6`，前面错过了 `4` 个数

在 `index = 2` 的地方 `arr[2] = 7`，前面错过了 `4` 个数

在 `index = 3` 的地方 `arr[3] = 9`，前面错过了 `4` 个数

总结规律，如果前面都缺失的话：

在 `index = i` 的地方 `arr[i] = num`，前面错过了 `arr[i] - (i + 1)` 个数



如果数组变成 `arr = [5, 6, 8, 9]`

在 `index = 3` 的地方 `arr[3] = 9`，前面错过了 `5` 个，而不是 `4` 个，所以**至少错过了** `arr[i] - (i + 1)` 个数。

由此得出我们二分时要求的是查找大于等于/大于 `target`的第一个元素，而且条件为：

```c++
arr[i] - (i + 1) >= k;
```



### **二分模板：**

#### 二、查找大于等于 / 大于 `target` 的第一个元素

这种通常题目描述为满足某种情况的**最小的元素**。

```c++
int left = 1, right = n;
while(left < right)
{
    int mid = (left + right) / 2;
    if(A[mid] >= target) // 如果要求大于等于可以加上等于，也可以是 check(A[mid])
        right = mid;
    else
        left = mid + 1;
}

// 或者写成这样：

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + right >> 1;
        if (nums[mid] >= target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
```



### 解法三：分类讨论，实质和二分相似

- 第1种情况：当缺失的数较多时，如`[7, 8, 9, 10], k = 5`，那缺失的第 `5` 个数就是 `5`，return `k`。

- 第2种情况：当前面的数并不缺失 时，如 `[1, 2, 3, 4, 5, 6], k = 5`，那缺失的第 `k` 个数为 `len+k = 6+5 = 11`，return `len + k`。

- 第3种情况：当 缺失的数大于 `k` 时，如 `[3, 4, 5, 9], k = 3`，总共缺了 `5` 个数，那么缺失的第 `k` 个数，即缺失的第 `3` 个数为多少？是 `6`。怎么求呢？



由解法二里分析的情况，至少错过 `arr[i] - (i + 1)` 个数的那个数是 `arr` 里的哪个数呢？

在 `index = 0` 的地方`arr[0] = 3`，前面缺失了 `2` 个数；

在 `index = 1` 的地方`arr[1] = 4`，前面缺失了 `2` 个数；

在 `index = 2` 的地方`arr[2] = 5`，前面缺失了 `2` 个数；

在 `index = 3` 的地方`arr[3] = 9`，前面缺失了 `5` 个数；

所以是从 `arr[3]` 开始的 

```c++
arr[i] - (i + 1) >= k;
```

所以第 `k` 个数为 `i + k`。



