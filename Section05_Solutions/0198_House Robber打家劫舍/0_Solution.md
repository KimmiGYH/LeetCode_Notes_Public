# 198 House Robber

## 方法一：暴力解法

暴力解法：检查所有房子的组合，对每一个组合，检查是否有相邻的房子，如果没有，记录其价值。找最大值。`O((2^n)*n)`

注意其中对**状态**的定义：

考虑偷取 `[x...n-1]` 范围里的房子（函数的定义）

根据对状态的定义，决定**状态的转移**：

```cpp
f(0) = max{ v(0) + f(2), v(1) + f(3), v(2) + f(4), ..., 
                v(n-3) + f(n-1), v(n-2), v(n-1) }  //（状态转移方程）
```

## 方法二：用两个数组来表示

看 **思路.png**

f(i) 表示 从 `1~i`中选，必选`i`
g(i) 表示 从 `1~i`中选，必不选`i`

f(i) 只有一种选择，`i`必选，所以看前面部分的`max`

前面部分相当于从`1 ~ i-1`中选，且必然不能选`i-1`，所以前面部分的最大值恰好是 `g(i-1)`

`w(i)`是第`i`个房子里可以偷的数量

`f(i) = g(i-1) + w(i)`

`g(i)` 有两种情况，选`i-1` 和 不选`i-1`

- 从 `1 ~ i-1`中选，且必然选 `i-1`：`f(i-1)`
- 从 `1 ~ i-1`中选，且必不选 `i-1`：`g(i-1)`
- 所以 `g(i) = max( f(i-1) , g(i-1) )`

## 方法三：用一个数组来表示
