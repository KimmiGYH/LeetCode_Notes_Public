---
export_on_save:
 html: true
---
# 983. Minimum Cost For Tickets_最低票价 (Medium)

**(动态规划)  $O(n)$**

**状态表示：** $f[i]$ 代表完成前 $i$ 个旅游日的旅行后，所有支付方案的集合；

**属性：** 最小值。

**状态转移方程：** $f[i] = min(f[i], f[j - 1] + cost)$

- $j$ 的含义是，完成前 $i$ 个旅游日的旅行时，最后一次买票，是在第 $j$ 个旅游日; 枚举 $j$ 求最小值。

- 状态 $f(i)$ 表示满足了前 $i$ 个日期的最少花费。日期和状态的下标都从 $1$ 开始。

- 初始值 $f(0) = 0$，其余为正无穷 `INT_MAX`。可以想到，每次买票一定选在某个存在的日期。

- 转移时，倒序枚举 $j$，$j$ 必须在没过期的窗口里，
  - 比如最后一次在第 $j$ 个旅游日购买了为期 $7$ 天的票，那 $days[j]$ 和 $days[i]$ 相差不能超过 $6$ 天；
  - 如果购买了为期 $30$ 天的票，则 $days[j]$ 和 $days[i]$ 小于 $30$ 天；
  - 如果两个日期差距大于等于 $30$ 天，则无需继续枚举, `break`。

- 转移方程的解释：在第 $j$ 个旅游日买了票，那么买票前花销就是 $f[j - 1]$，加上这次的花销即可。求的是最小值，所以集合内取 $min$。
$$
f(i) = \min(f(i), f(j - 1) + cost(k))，k 表示对应的价钱。
$$

- 最终答案为 $f(n)$。

**时间复杂度：** 
$O(30 * n)$ 即 $O(n)$

- 对于每一个需要旅行的日子，只需要探索它前面 $30$ 天的窗口即可
- 状态数为 $O(n)$ 个，注意到每次转移最多只有 $30$ 个，故总时间复杂度为 $O(n)$。
