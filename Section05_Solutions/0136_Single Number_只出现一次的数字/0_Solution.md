# 136 Single Number 只出现一次的数字

## 解法一：位运算 - 异或

异或的性质：

- 交换律： `a^b = b^a`
- 结合律
- 两个相同的数异或结果为 $0$：`x^x = 0`

1. 两个相同的数字经过异或之后会变为 $0$。
2. 将数组所有元素异或在一起，只出现一次的数字异或后的值会保留下来，即可得到出现 $1$ 次的元素值。

**时间复杂度：**

- 仅遍历一次数组，故时间复杂度为 $O(n)$。

**空间复杂度：**

- 仅需要常数的额外空间。

==========

答案是使用位运算。对于这道题，可使用异或运算 `⊕`。异或运算有以下三个性质。

- 任何数和 `0` 做异或运算，结果仍然是原来的数，即 `a ⊕ 0 = a`。
- 任何数和其自身做异或运算，结果是 `0`，即 `a ⊕ a = 0`。
- 异或运算满足交换律和结合律，即 `a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b ⊕ 0 = b`。

题⽬为什么要强调有⼀个数字出现⼀次，其他的出现两次？我们想到了异或运算的性质：任何⼀个
数字异或它⾃⼰都等于0。也就是说，如果我们从头到尾依次异或数组中的每⼀个数字，那么最终
的结果刚好是那个只出现依次的数字，因为那些出现两次的数字全部在异或中抵消掉了。于是最终
做法是从头到尾依次异或数组中的每⼀个数字，那么最终得到的结果就是两个只出现⼀次的数字的
异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。 利⽤的性质是 **x^x = 0**。  

**复杂度分析：**

时间复杂度：`O(n)`，其中 `n` 是数组长度。只需要对数组遍历一次。

空间复杂度：`O(1)`。

## 方法二

可以用`unordered_map`去重每个元素数目，然后遍历一下取出来个数为`1`的元素。
