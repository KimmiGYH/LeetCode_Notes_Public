# 74. Search a 2D Matrix_搜索二维矩阵



## 解法一：展开二分 `O(logn)`

我们可以想象把整个矩阵，按行展开成一个**一维数组**，那么这个一维数组单调递增，然后直接二分即可。
二分时可以通过整除和取模运算得到二维数组的坐标。

```c++
row = mid / n;
col = mid % n;
```

时间复杂度分析：二分的时间复杂度是 $O(logn^2) = O(logn)$



## 解法二：单调性扫描 `O(n + m)`

**(单调性扫描) $O(n+m)$**

1. 初始化 `row = 0`，`col = n - 1`，从**右上角元素**开始。

2. 如果发现 `matrix[row][col] == target`，则直接返回 `true`；

3. 若 `target < matrix[row][col]`，则向左移动 `col--`；

4. 若 `target > matrix[row][col]`，则向下移动 `row--`；

5. 如果出界返回 false。



时间复杂度：
可以看到每次 `row` 向下移动或者 `col` 向左移动，移动次数不超过 `n+m` 次，故时间复杂度为 $O(n+m)$。



## 解法三：四个方向二分压缩 $O(k(logn+logm))$

**(二分) O(k(logn+logm))**

1. 初始化上下左右边界 `up`, `down`, `left`, `right`，保证 `target` 可能出现在此区域。
2. 每次在 `up` 行中，二分求出新的 `right`；在 `down` 行中，二分求出新的 `left`；
3. 接着在 `2` 求出的 `left` 列中，二分求出新的 `down`；在 `2` 求出的 `right` 列中，二分求出新的 `up`；
4. 如果 `up == down` && `left == right`，则判断 `matrix[up][left] == target`。
5. 注意，如果一轮迭代更新中，四个元素的值都没有变化，则说明那一片区域有多个 `target`，直接返回 `true`。



时间复杂度：

- 每次迭代时间复杂度为 `O(log⁡n+log⁡m)`，假设需要 `k` 次迭代，故时间复杂度为 $O(k(logn+logm))$。

- 最坏情况可能 `k=min(n,m)`，但平均情况下很难达到最坏情况。

空间复杂度：

- 仅需要常数的额外空间。



## 解法四：右上两个方向往左下二分压缩



思路和解法三一样，但可以少写一半的代码。
