# 74. Search a 2D Matrix_搜索二维矩阵

## 解法一：展开成一维后二分 $O(\log m*n)$

我们可以想象把整个矩阵，按行展开成一个**一维数组**，那么这个一维数组单调递增，然后直接二分即可。
二分时可以通过整除和取模运算得到二维数组的坐标。

```c++
row = mid / n;
col = mid % n;
```

**复杂度分析：**

- 时间复杂度：$O(\log m*n)$，其中 $m$ 和 $n$ 分别是矩阵的行数和列数。
- 空间复杂度：$O(1)$。

## 解法二：$BST$ 思维，单调性扫描 $O(n + m)$

![BST思维](https://pic.leetcode-cn.com/1617066993-AyRIiF-image.png)

**(单调性扫描) $O(n+m)$**

- 那么我们可以从根（右上角）开始搜索，如果当前的节点不等于目标值，可以按照树的搜索顺序进行：
  - 当前节点「大于」目标值，搜索当前节点的「左子树」，也就是当前矩阵位置的「左方格子」，即 $col--$
  - 当前节点「小于」目标值，搜索当前节点的「右子树」，也就是当前矩阵位置的「下方格子」，即 $row++$

1. 初始化 `row = 0`，`col = n - 1`，从**右上角元素**开始。

2. 如果发现 `matrix[row][col] == target`，则直接返回 `true`；

3. 若 `target < matrix[row][col]`，则向左移动 `col--`；

4. 若 `target > matrix[row][col]`，则向下移动 `row++`；

5. 如果出界返回 false。

**时间复杂度**：

- 时间复杂度：可以看到每次 `row` 向下移动或者 `col` 向左移动，移动次数不超过 `n+m` 次，故时间复杂度为 $O(n+m)$。
- 空间复杂度：$O(1)$

## 解法三：两次二分  $O(\log m*n)$

- 由于二维矩阵固定列的「从上到下」或者固定行的「从左到右」都是升序的。
- 因此我们可以使用两次二分来定位到目标位置：

  - 第一次二分：从第 $0$ 列中的「所有行」开始找，找到合适的行 $row$

  - 第二次二分：从 $row$ 中「所有列」开始找，找到合适的列 $col$

**复杂度分析：**
- 时间复杂度：$O(\log{m} + \log{n}) = O(log{m*n})$，其中 $m$ 和 $n$ 分别是矩阵的行数和列数。
- 空间复杂度：$O(1)$

## （弃）解法四：四个方向二分压缩 $O(k(logn+logm))$

**(二分)** $O(k(logn+logm))$

1. 初始化上下左右边界 `up`, `down`, `left`, `right`，保证 `target` 可能出现在此区域。
2. 每次在 `up` 行中，二分求出新的 `right`；在 `down` 行中，二分求出新的 `left`；
3. 接着在 `2` 求出的 `left` 列中，二分求出新的 `down`；在 `2` 求出的 `right` 列中，二分求出新的 `up`；
4. 如果 `up == down` && `left == right`，则判断 `matrix[up][left] == target`。
5. 注意，如果一轮迭代更新中，四个元素的值都没有变化，则说明那一片区域有多个 `target`，直接返回 `true`。

**时间复杂度**：

- 每次迭代时间复杂度为 `O(log⁡n+log⁡m)`，假设需要 `k` 次迭代，故时间复杂度为 $O(k(logn+logm))$。

- 最坏情况可能 `k=min(n,m)`，但平均情况下很难达到最坏情况。

**空间复杂度**：

- 仅需要常数的额外空间。

## （弃）解法四：右上两个方向往左下二分压缩

思路和解法三一样，但可以少写一半的代码。
