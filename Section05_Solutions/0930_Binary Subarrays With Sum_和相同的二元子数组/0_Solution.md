# 930_Binary Subarrays With Sum_和相同的二元子数组

## 解法一：前缀和 + 哈希表 $O(n)$

题目大意：给我们一个数组，求有多少个子数组的总和等于 $goal$？

- 预处理前缀和，算 $nums$ 的前缀和 $sum$
- 枚举以 $i$ 为右端点的所有子数组中，有多少个子数组的和等于 $goal$

**复杂度分析**
- 时间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。对于数组中的每个元素，我们至多只需要插入到哈希表中中一次。
- 空间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。哈希表中至多只存储 $O(n)$ 个元素。


## 解法二：双指针+滑动窗口

```cpp
/**Ex:
index   0,1,2,3,4
nums = [1,0,1,0,1], goal = 2
sum  = [1,1,2,2,3]
*/
int atMost(vector<int>& nums, int goal) {
    int n = nums.size(), cnt = 0;
    if (goal < 0) return 0;
    for (int i = 0, j = 0, sum = 0; j < n; j++) {
        sum += nums[j];
        while (sum > goal) {
            sum -= nums[i];
            i++;
        }
        cnt += j - i + 1;
        //goal=2: cnt = 1 2 3 4  4
        //              1 3 6 10 14
        //goal=1: cnt = 1 2 2 3  2
        //              1 3 5 8  10 
    }
    return cnt;
}
```

- 用 $atMost(nums, goal) - atMost(nums, goal - 1)$ 来求和为 $goal$ 的非空子数组。
- 和最多为 $2$ 的子数组为: [1] , [0] , [1,0] , [1,0,1] ...
- 和最多为 $2$ 的子数组为: [1] , [0], [1,0] ... 
- 用前者的数量减去后者的数量，就是和正好为 $2$ 的子数组的数量

## 解法二：双指针-滑动窗口 (看不懂，不好理解)

```
index   0,1,2,3,4
nums = [1,0,1,0,1], goal = 2
sum  = [1,1,2,2,3]
            l1  l2
```

- 注意到对于方法一中每一个 $i$，满足 $sum[i] - sum[j] = goal$ 的 $j$ 总是落在一个连续的区间中，$j$ 值取区间中每一个数都满足条件。
- 并且随着 $i$ 右移，其对应的区间的左右端点也将右移，这样我们即可使用滑动窗口解决本题。
- 具体地，我们令滑动窗口右边界为 $r$，使用两个左边界 $l1$ 和 $l2$ 表示左区间 $[l1, l2)$，此时有 $l2-l1$ 个区间满足条件。
- 在实际代码中，我们需要注意 $l1 \le l2 \le r+1$，因此需要在代码中限制 $l1$ 和 $l2$ 不超出范围。

- 由于无负值，而且是非 $0$ 即 $1$，这样才确保了窗口 $[l1, r]$ 的元素和刚好为 $goal$
- 窗口 $[l2, r]$ 是左端点在 $l1$ 右边的、第一个元素和小于 $goal$ 的窗口
- 这样意味着所有 $l1 \le l <l2$ 对应的子数组 $[l, r]$ 的元素和都为 $goal$，所以才 $res += l2 - l1$

**复杂度分析**
- 时间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。我们至多只需要遍历一次该数组。
- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。
