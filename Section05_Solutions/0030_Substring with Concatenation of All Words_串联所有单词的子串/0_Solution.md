# 30_Substring with Concatenation of All Words_串联所有单词的子串

## 解法一：双指针+滑动窗口

- 先考虑一共要枚举哪些情况？
    ```
    n: s.size()
    m: words.size()
    w: words[0].size()
    ```
- 可以把所有的起始位置做分类，按照所有起始位置对于 $w$ 的余数来分类
    ```
    |-----------------------------------------|
    0      w      2w      3w      ...
    1      w+1    2w+1    3w+1    ...
    ......
    w-1   2w-1    3w-1    4w-1    ...
    ```
- 问题变成：在 $s$ 中找到连续的 $m$ 个单词，恰好是 $words$ 给定的 $m$ 个元素，使用滑动窗口
- 用长度为 $m$ 的滑动窗口来维护所有长度为 $m$ 的连续子段（窗口里所有的单词也存到哈希表中），每次窗口往后移动一位都会增加一个单词，删除一个旧的单词
- 判断**当前哈希表**维护的集合，与 $words$ 对应的**给定哈希表**集合 是否一致？如果元素数量一一对应，那就说明 $s$ 中连续 $m$ 个单词就是  $words$ 给定的 $m$ 个单词
- 如何判断两个哈希表集合相等？除了维护哈希表之外，还要用个变量 $cnt$ 去存当前哈希表集合中有多少个**有效**单词是给定的集合里的。有两层含义：种类、数量 都一致。

**复杂度分析**
- 时间复杂度：$O(n*m)$
  - 每次扫描一组，两个指针均最多移动 $\dfrac{n}{w}$ 次
  - 虽然哈希表操作是 $O(1)$，但每组每次移动时哈希表操作的复杂度其实是这个单词的长度 $O(w)$
  - 所以每组时间复杂度为 $O(\dfrac{n}{w}*w) = O(n)$
  - 一共有 $m$ 组，所以整体复杂度是 $O(n*m)$
