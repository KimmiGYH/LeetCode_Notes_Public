# 343. Integer Break

## 方法一：数论

### 解释1

结论：尽可能分成`3`和`2`，而且`2`的个数不能超过两个（最多只能有两个`2`）。`n ≥ 4` 的情况都是不需要考虑的。

这道题目是数学中一个很经典的问题。
下面我们给出证明：

首先把一个正整数 `N` 拆分成若干正整数只有有限种拆法，所以存在最大乘积。
假设 `N = n1 + n2 + … + nk`，并且 `n1 × n2 × … × nk` 是最大乘积。

- 显然`1`不会出现在其中；
- 如果对于某 `i` 有 `ni≥5`，那么把 `ni` 拆分成 `3+(ni−3)`，我们有 `3(ni−3)=3ni−9>ni`；这解释了为什么不能拆出`5`：`5`可以拆成`2`和`3`, `2×3 = 6 > 5`，同理`5`以上的数也一样
- 如果 `ni=4`，拆成 `2+2` 乘积不变，所以不妨假设没有`4`；
- 如果有三个以上的`2`，那么 `3×3 > 2×2×2`，所以替换成`3`乘积更大；
- 综上，选用尽量多的`3`，直到剩下`2`或者`4`时，用`2`。

时间复杂度分析：当 `n` 比较大时，`n` 会被拆分成 `⌈n/3⌉` 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 `O(n)`。

### 解释2

(数学法) O(1)

- 这是一个非常经典的数学问题
- 先说结论：想让分割出的数乘积最大，优先拆成`3`，其次是`2`
- 为什么不能拆出`5`：`5`可以拆成`2`和`3`, `2×3 = 6 > 5`，同理`5`以上的数也一样
- 为什么不能拆出`1`：`1`对乘积无影响，且把`1`加到其他分割出的数上乘积更大
- 拆出`4`对结果无影响：`2×2 = 4`

### 解释3

(1) 求分解后的乘积最大 -> 看下什么时候分解乘积相等：

```cpp
    3 = 1 + 2 > 1 * 2
    4 = 2 + 2 = 2 * 2
    5 = 2 + 3 < 2 * 3
    6 = 3 + 3 = 2 + 2 + 2 ; 3 * 3 > 2 * 2 * 2 > 1 * 2 * 3 > 1 * 5
```

(2) 可以看出任何比 `3` 大的数都能分解成 `1` or `2` or `3` 的乘积
    分解出`1`, 乘积会变小
    分解出`3`的结果比分解出`2`的大, 如果分解出`>3`的数, 结果必定比分解出 `2<= && <=3` 的数小

(3) 所以尽量分解出更多的`3`

### 复杂度分析

时间复杂度：`O(1)`。涉及到的操作包括计算商和余数，以及幂次运算，时间复杂度都是常数。

空间复杂度：`O(1)`。只需要使用常数复杂度的额外空间。

## 方法二：动态规划

对于的正整数 `n`，当 `n≥2` 时，可以拆分成至少两个正整数的和。
令 `k` 是拆分出的第一个正整数，则剩下的部分是 `n-k`，`n-k` 可以不继续拆分，或者继续拆分成至少两个正整数的和。
由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。
创建数组 `dp`，其中 `dp[i]` 表示将正整数 `i` 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，`0` 不是正整数，`1` 是最小的正整数，`0` 和 `1` 都不能拆分，因此 `dp[0] = dp[1] = 0`。

当 `i ≥ 2` 时，假设对正整数 `i` 拆分出的第一个正整数是 `j` (1 ≤ j < i)，则有以下两种方案：

- 将 `i` 拆分成 `j` 和 `i-j` 的和，且 `i-j` 不再拆分成多个正整数，此时的乘积是 `j × (i−j)`；
- 将 `i` 拆分成 `j` 和 `i-j` 的和，且 `i-j` 继续拆分成多个正整数，此时的乘积是 `j × dp[i−j]`。

因此，当 `j` 固定时，有 `dp[i] = max(j×(i−j), j×dp[i−j])`。由于 `j` 的取值范围是 `1` 到 `i-1`，需要遍历所有的 `j` 得到 `dp[i]` 的最大值，因此可以得到状态转移方程如下：

![状态转移方程](https://raw.githubusercontent.com/KimmiGYH/LeetCode_Notes_Public/master/Section05_Solutions/0343_Integer%20Break_%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png)

最终得到 `dp[n]` 的值即为将正整数 `n` 拆分成至少两个正整数的和之后，这些正整数的最大乘积。

### 复杂度分析

时间复杂度：`O(n^2)`，其中 `n` 是给定的正整数。对于从 `2` 到 `n` 的每一个整数都要计算对应的 `dp` 值，计算一个整数对应的 `dp` 值需要 `O(n)` 的时间复杂度，因此总时间复杂度是 `O(n^2)`。

空间复杂度：`O(n)`，其中 `n` 是给定的正整数。创建一个数组 `dp`，其长度为 `n+1`。

## 方法三：优化动态规划

`n ≥ 4` 的情况都是不需要考虑的。

由于在使用 `j × dp[i−j]` 计算 `dp[i]` 时，`j=2` 和 `j=3` 的情况一定优于 `j≥4` 的情况，因此无论是考虑 `j × dp[i−j]` 还是考虑 `j × (i−j)`，都只需要考虑 `j=2` 和 `j=3` 的情况。

由此可以对方法一的动态规划进行优化。

边界情况是 `n=2`，此时唯一的拆分方案是 `2=1+1`，最大乘积是 `1×1=1`。

当 `i≥3` 时，状态转移方程如下：

![优化的状态转移方程](https://raw.githubusercontent.com/KimmiGYH/LeetCode_Notes_Public/master/Section05_Solutions/0343_Integer%20Break_%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/%E4%BC%98%E5%8C%96%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png)
