# 881. Boats to Save People_救生艇 (Medium)



载人过河，每个人的体重不同，每条船承重有个限度 limit（限定了这个载重大于等于最重人的体重），同时要求每条船不能超过两人。

从题目中的例子2可以看出，最胖的人有可能一人占一条船，当然如果船的载量够大的话，可能还能挤上一个瘦子，那么最瘦的人是最可能挤上去的，所以**策略就是胖子加瘦子的上船组合**。那么这就是典型的贪婪算法的适用场景。

- 首先要给所有人按体重排个序，从瘦子到胖子，这样我们才能快速的知道当前最重和最轻的人。
- 然后使用双指针，`l` 指向最瘦的人，`r` 指向最胖的人，当 `l <= r` 的时候，进行 `while` 循环。
- 在循环中，胖子是一定要上船的，所以 `r` 自减`1`是肯定有的，但是还是要看能否再带上一个瘦子，能的话 `l` 自增 `1`。然后结果 `res` 一定要自增 `1`，因为每次都要用一条船。

**算法过程**

先对 $people$ 进行排序，然后使用两个指针 `l` 和 `r` 分别从首尾开始进行匹配：
- 如果 $people[l] + people[r] <= limit$，说明两者可以同船，此时船的数量加一，两个指针分别往中间靠拢，`l` 指针右移，`r` 指针左移；

- 如果 $people[l] + people[r] > limit$，说明不能成组，由于题目确保人的重量不会超过 $limit$，此时让 $people[r]$ 独立成船，船的数量加一，`r` 指针左移。






**复杂度分析**

- 时间复杂度：排序复杂度为 $O(n\log{n})$；双指针统计答案复杂度为 $O(n)$。整体复杂度为 $O(n\log{n})$
- 空间复杂度：$O(\log{n})$，排序所需额外的空间复杂度为 $O(\log n)$

