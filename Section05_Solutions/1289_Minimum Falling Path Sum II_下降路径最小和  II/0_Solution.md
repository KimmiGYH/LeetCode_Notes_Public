# 1289_Minimum Falling Path Sum II_下降路径最小和  II

## 解法一：三重循环，较慢 $O(m * n^2)$

1. 设 $f(i, j)$ 表示到达第 $i$ 行第 $j$ 列时的最小值。
2. 初始时 $f(0, j) = arr(0, j)$，其余为正无穷。
3. 转移时，枚举 $k$，当 $j \neq k$ 时，转移 $f(i, j) = \min(f(i, j), f(i - 1, k) + arr(i, j))$。
4. 最终答案为 $\min(f(n - 1, j))$。

**时间复杂度：**

- 共有 $m*n$ 个状态，每个状态有 $O(m)$ 种转移，故时间复杂度为 $O(m*n^2)$。

**空间复杂度：**

- 需要 $O(nm)$ 的空间存储状态。
- 可以利用滚动数组优化到 $O(m)$ 的空间。

## 解法二：动态规划 $O(m*nlogn)$

[Youtube视频：【每日一题】1289. Minimum Falling Path Sum II](https://youtu.be/euD2WFdUp6U)

- 如果不在同一列，就找出上一行中的非同一列的最大值
- 如果在同一列，就找出上一行中的非同一列的次大值
- 可以用 `sort` 进行排序，找出最大值、次大值

## 解法三：(动态规划优化)  $O(m*n)$

1. 在 算法一 的基础上优化，不再枚举 $O(m)$ 种转移。
2. 额外开两个数组 $left(i, j)$ 和 $right(i, j)$ 分别记录第 $i$ 行，从第 $0$ 列到第 $j$ 列的最小值和从第 $m - 1$ 列到第 $j$ 列的最小值。
3. 这样每次转移就只需要 $f(i, j) = \min(left(i - 1, j - 1), right(i - 1, j + 1)) + arr(i, j)$。

**时间复杂度：**

- 共有 $m*n$ 个状态，每次转移只需要常数时间，故时间复杂度为 $O(m*n)$。

**空间复杂度：**

- 需要 $O(m*n)$ 的空间存储状态。
- 可以利用滚动数组优化到 $O(m)$ 的空间。
