# 825_Friends Of Appropriate Ages_适龄的朋友

## 解法一：统计 补集思想 $O(n+A)$

- 先统计一下每个年龄有多少个人
- 用补集思想，一共有 $n^{2}$ 个请求（这里包括了自环），减去不合法的有向边的数量，剩余的是合法的有向边数量
- 如何枚举？人数有两万，而年龄只有 $120$，所以可以枚举所有对年龄
```cpp
for i: 1 ~ 120
    for j: 1 ~ 120
        if 满足条件：
            res -= S[i] * S[j];
        else if (i==j) //减去自环
            res -= S[i];
return res;
```
**复杂度分析**
- 时间复杂度：扫描一遍原数组，扫描一遍所有年龄，故时间复杂度为 $O(n+A)$。
- 空间复杂度：需要额外的空间记录每个年龄有多少人，故空间复杂度为 $O(A)$。


## 解法二：排序+双指针 $O(n\log{n})$

从三个不发送好友请求的条件来看，以 $y$ 的角度来说，可总结为：**年龄比我小的不考虑（同龄的可以），年龄比我大可以考虑，但是不能超过一定范围则不考虑。**

即对于一个确定的 $y$ 而言，会发送好友请求的 $x$ 范围为连续段：
![会发送好友请求的 x 范围为连续段](https://pic.leetcode-cn.com/1640558862-McjmOR-image.png)

- 因此，我们可以先对 $ages$ 进行排序，枚举每个 $y = ages[k]$，
- 同时使用 $i$ 和 $j$ 维护左右区间，$[i, j)$ 代表在 $ages$ 上会往 $y = ages[k]$ 发送请求的 $x$ 连续段，
- 统计每个 $y = ages[k]$ 的 $x$ 有多少个即是答案，同时需要注意在 $[i, j)$ 范围内是包含 $y = ages[k]$ 自身，统计区间长度时需要进行 $−1$ 操作。

**时间复杂度**
- 时间复杂度：$O(n\log{n})$
- 空间复杂度：$O(\log{n})$


