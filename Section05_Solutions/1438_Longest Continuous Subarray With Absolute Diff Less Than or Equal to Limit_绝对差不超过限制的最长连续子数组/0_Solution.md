# 1438_Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit_绝对差不超过限制的最长连续子数组

## 解法一：$multiset$ + 滑动窗口

题意：求一个最长的子数组，该子数组内的最大值和最小值的差不超过 $limit$。

- 本题是求最大连续子区间，可以使用滑动窗口方法。滑动窗口的限制条件是：窗口内最大值和最小值的差不超过 $limit$。
- 本题最大的难点在于快速地求滑动窗口内的最大值和最小值，类似题目如 480. 滑动窗口中位数。
- 如果遍历求滑动窗口内的最大值和最小值，时间复杂度是 $O(k)$，肯定会超时。降低时间复杂度的一个绝招就是增加空间复杂度：利用更好的数据结构。是的，我们的目的是快速让一组数据有序，那就寻找一个内部是**有序的数据结构**。下面我分语言讲解一下常见的内部有序的数据结构。
  - 在 C++ 中 $set/multiset/map$ 内部元素是有序的，它们都基于**红黑树**实现。其中 $set$ 会对元素去重，而 $multiset$ 可以有重复元素。
  - 在 Java 中 $TreeSet$ 是有序的去重集合，$TreeMap$ 是带 $key$ 有序集合，它们也是基于红黑树实现的。
  - 第三方的平衡树库，例如 $Python$ 中的 $sortedcontainers$（事实上，这个库的底层实现并不是平衡树，但各种操作的时间复杂度仍然很优秀）；

- 下面这个图是 C++ 的 $multiset$ 内部结构示意图（Java 的 $TreeSet$ 也类似，但没有重复元素），它是个平衡二叉搜索树（$BST$），插入元素时会自动调整二叉树，使得每个子树根节点的键值大于左子树所有节点的键值，同时保证根节点左右子树的高度相等。这样二叉树高度最小，检索速度最快。它的中序遍历是有序的，另外它也允许出现重复的值。

- 当频繁的插入和删除元素时，$multiset/map$ 和 $TreeMap$ 等有序的数据结构能够在在 $O(log(k))$ 的时间复杂度内调整 $BST$，从而维护结构的有序性。


    ![BST](https://pic.leetcode-cn.com/1612321227-bFppUa-image.png)

**算法过程**
- 使用 $left$ 和 $right$ 两个指针，分别指向滑动窗口的左右边界；定义 $multiset$ 保存滑动窗口的所有元素；
- $right$ **主动**右移：$right$ 指针每次移动一步，把 $nums[right]$ 放入滑动窗口；
- $left$ **被动**右移：判断此时窗口内最大值和最小值的差，如果大于 $limit$，则 $left$ 指针被迫右移，直至窗口内最大值和最小值的差小于等于 $limit$ 为止；$left$ 每次右移之前，需要把 $nums[left]$ 从 $multiset$ 中减去一次。
- 滑动窗口长度的最大值就是所求。

**复杂度分析**
- 时间复杂度：$O(n*log(n))$，每个元素遍历一次，新元素插入红黑树的调整时间为 $O(log(n))$；
- 空间复杂度：$O(n)$。

## 解法二：滑动窗口 + 单调队列

- 在方法一中，我们仅需要统计当前窗口内的最大值与最小值，因此我们也可以分别使用两个单调队列解决本题。

- 在实际代码中，我们使用一个单调递增的队列 $minq$ 维护最小值，一个单调递减的队列 $maxq$ 维护最大值。这样我们只需要计算两个队列的队首的差值，即最大值减去最小值，即可知道当前窗口是否满足条件。

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组长度。我们最多遍历该数组两次，两个单调队列入队出队次数也均为 $O(n)$。
- 空间复杂度：$O(n)$，其中 $n$ 是数组长度。最坏情况下单调队列将和原数组等大。

