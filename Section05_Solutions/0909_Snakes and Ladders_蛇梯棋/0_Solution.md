# 909. Snakes and Ladders_蛇梯棋 (Medium)



## 解法一：BFS (Floodfill)



这道题给了一个 `NxN` 大小的二维数组，从左下角从1开始，蛇形游走，到左上角或者右上角到数字为 `NxN`，中间某些位置会有梯子，就如同传送门一样，直接可以到达另外一个位置。现在就如同玩大富翁 Big Rich Man 一样，有一个骰子，可以走 `1` 到 `6` 内的任意一个数字，现在奢侈一把，有无限个遥控骰子，每次都可以走 `1` 到 `6` 以内指定的步数，问最小能用几步快速到达终点 `NxN` 位置。

注意：求最小值，除了动态规划 Dynamic Programming，还有一大神器，广度优先搜索 **BFS**，最直接的应用就是在迷宫遍历的问题中，**求从起点到终点的最少步数**，也可以用在更 general 的场景。



这道题基本就是类似迷宫遍历的问题，可以走的 `1` 到 `6` 步可以当作六个方向，这样就可以看作是一个迷宫了。
唯一要特殊处理的就是遇见梯子的情况，要跳到另一个位置。

这道题还有另一个难点，就是数字标号和数组的二维坐标的转换，这里起始点是在二维数组的左下角，且是`1`，而代码中定义的二维数组的 `(0, 0)` 点是在左上角，需要转换一下；还有就是这道题的数字是**蛇形环绕**的，即当行号是奇数的时候，是从右往左遍历的，转换的时候要注意一下。



- 难点基本都提到了，现在开始写代码吧，既然是 **BFS**，就需要用队列 `queue` 来辅助，初始时将数字 `1` 放入，然后还需要一个 `visited` 数组，大小为 `n*n+1`。

- 在 `while` 循环中进行层序遍历，取出队首数字，判断若等于 `n*n` 直接返回结果 `steps`。否则就要遍历 `1` 到 `6` 内的所有数字 `i`，则 `num+i` 就是下一步要走的距离，需要将其转为数组的二维坐标位置，这个操作放到一个单独的子函数中。

- 有了数组的坐标，就可以看该位置上是否有梯子，有的话，需要换成梯子能到达的位置，没有的话还是用 `num + i`。

- 有了下一个位置，再看 `visited` 中的值，若已经访问过了直接跳过，否则标记为 `true`，并且加入队列 `queue` 中即可，若 `while` 循环退出了，表示无法到达终点，返回 -1。

- 将数字标号转为二维坐标位置的子函数也不算难，首先应将数字标号减 `1`，因为这里是从 `1` 开始的，而代码中的二维坐标是从 `0` 开始的，然后除以 `n` 得到横坐标，对 `n` 取余得到纵坐标。但这里得到的横纵坐标都还不是正确的，因为前面说了数字标记是蛇形环绕的，当行号是奇数的时候，列数需要翻转一下，即用 `n-1` 减去当前列数。又因为代码中的二维数组起点位置在左上角，同样需要翻转一样，这样得到的才是正确的横纵坐标，返回即可。

  ![solve](https://raw.githubusercontent.com/KimmiGYH/LeetCode_Notes_Public/master/Section05_Solutions/0909_Snakes%20and%20Ladders_%E8%9B%87%E6%A2%AF%E6%A3%8B/solve.png)

  ```c++
  vector<int> getPosition(int &n, int num) {
          int row = 0, col = 0;
          int x = (num - 1) / n, y = (num - 1) % n;
          if (x % 2) col = (n - 1) - y;
          else col = y;
          row = (n - 1) - x;
          return {row, col};
      }
  ```

