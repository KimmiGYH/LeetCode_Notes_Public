# 416. Partition Equal Subset Sum_分割等和子集 (Medium)



## 解法一：动态规划DP



给到一个数组，问这个数组能不能分成两个非空子集合，使得两个子集合的元素之和相同。

相当于 **01背包问题**：

- 数组里的数是物品 ，是数组里的元素，物品这里没有价值
- 背包容量是 `sum/2`

**01背包模板：**

```c++
for (int i = 1; i <= n; i++)
    for (int j = target; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
return f[target];
```

原数组所有数字和一定是**偶数**，不然根本无法拆成两个和相同的子集合，只需要算出原数组的数字之和，然后除以`2`，就是 `target`，那么问题就转换为能不能找到一个非空子集合，使得其数字之和为 `target`。

```c++
for (auto x : nums)
    for (int j = target; j >= x; j--)
        f[j] |= f[j - x];
return f[target];
```

**具体步骤：**

1. 定义一个一维的 `dp` 数组，其中 `dp[i]` 表示**原数组是否可以取出若干个数字**，其和为 `i`。那么最后只需要返回 `dp[target]` 就行了。

2. 初始化 `dp[0]` 为 `true`，找出状态转移方程，需要遍历原数组中的数字，对于遍历到的每个数字 `nums[i]`，需要更新 `dp` 数组

3. 既然最终目标是想知道 `dp[target]` 的 `boolean` 值，就要想办法用数组中的数字去凑出 `target`，因为都是正数，所以只会越加越大，加上 `nums[i]` 就有可能会组成区间 `[nums[i], target]` 中的某个值，那么对于这个区间中的任意一个数字 `j`，如果 `dp[j - nums[i]]` 为 `true` 的话，说明现在已经可以组成 `j-nums[i]` 这个数字了，再加上 `nums[i]`，就可以组成数字 `j` 了，那么 `dp[j]` 就一定为 `true`。

4. 如果之前 `dp[j]` 已经为 `true` 了，当然还要保持 `true`，讨论物品**选或不选**，所以还要 **‘或’ 上自身**，于是状态转移方程如下：

   ```cpp
   dp[j] = dp[j] || dp[j - nums[i]]     (nums[i] <= j <= target)
       
   // 或者写成
   dp[j] |= dp[j - nums[i]]
   ```

   

5. 有了状态转移方程，就可以写出代码了，这里需要特别注意的是，第二个 `for` 循环一定要从 `target` 遍历到 `nums[i]`，而不能反过来，想想为什么呢？因为如果从 `nums[i]` 遍历到 `target` 的话，假如 `nums[i] = 1` 的话，那么 `[1, target]` 中所有的 `dp` 值都是 `true`，因为 `dp[0]` 是 `true`，`dp[1]` 会或上 `dp[0]`，为 `true`，`dp[2]` 会或上 `dp[1]`，为 `true`，依此类推，完全使的 dp 数组失效了。





## 解法二：`bitset`

![solve]()



这道题还可以用 `bitset` 来做，感觉也十分的巧妙，`bisets` 的大小设为 `10001`，因为题目中说

1. 每个数组中的元素不会超过 `100`
2. 数组的大小不会超过 `200`

那么最大的和为 `20000`，那么一半就是 `10000`，前面再加上个 `0`，就是 `10001` 了。



初始化把最低位赋值为 `1`，算出数组之和，然后遍历数字，对于遍历到的数字 `num`，把 `bits` 向左平移 `num` 位，然后再**或**上原来的 `bits`，这样所有的可能出现的和位置上都为 `1`。

**举例：**

- 比如对于数组 `[1, 2, 3, 5]` 来说，初始化 `bits` 为 `1`
- 对于数字 `1`，`bits` 变为 `11`，`bits[1]` 标记为了 `1`，

- 然后对于数字 `2`，`bits` 变为 `101`，可以看出来 `bits[2]` 标记为了 `1`，
- 然后遍历到 `3`，`bits` 变为了 `1101`。
- 如果 `bits` 变成 `101101`，可以看到 `bits[5]`，`bits[3]`，`bits[2]` 都分别为 `1` 了，正好代表了可能的和 `2，3，5`
- 这样遍历完整个数组后，去看 `bits[sum >> 1]` 是否为 `1` 即可确定是否能将这个数组风格陈两个子集了。