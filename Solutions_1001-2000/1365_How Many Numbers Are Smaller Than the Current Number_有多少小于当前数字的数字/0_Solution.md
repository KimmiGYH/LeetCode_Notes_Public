# 1365_How Many Numbers Are Smaller Than the Current Number_有多少小于当前数字的数字

## 解法一：暴力 $O(n^{2})$

- 比较容易想到的一个方法是，对于数组中的每一个元素，我们都遍历数组一次，统计小于当前元素的数的数目。
- 用数组存频率可以避免重复

**复杂度分析**
- 时间复杂度：$O(n^{2})$，其中 $n$ 为数组的长度。
- 空间复杂度：$O(1)$。注意我们不计算答案数组的空间占用。

## 解法二：排序+哈希表 $O(n\log n)$

- 首先要找小于当前数字的数字，那么从小到大排序之后，该数字之前的数字就都是比它小的了。
- 可以定义一个新数组，将数组排个序。
- 排序之后，其实每一个数值的下标就代表这前面有几个比它小的了。
- 用一个哈希表hash（本题可以就用一个数组）来做数值和下标的映射。这样就可以通过数值快速知道下标（也就是前面有几个比它小的）。
- 此时有一个情况，就是数值相同怎么办？（如何处理数值相同的情况）
  - 例如，数组：$1 2 3 4 4 4$ ，第一个数值 $4$ 的下标是 $3$，第二个数值 $4$ 的下标是 $4$ 了。
  - 这里就需要一个技巧了，**在构造数组 $hash$ 的时候，从后向前遍历，这样 $hash$ 里存放的就是相同元素最左面的数值和下标了**。

    ```cpp
    int hash[101];
    for (int i = vec.size() - 1; i >= 0; i--) { // 从后向前，记录 vec[i] 对应的下标
        hash[vec[i]] = i;
    }
    ```
- 最后在遍历原数组 $nums$，用 $hash$ 快速找到每一个数值 对应的 小于这个数值的个数。存放在将结果存放在另一个数组中。

**复杂度分析**

- 时间复杂度：$O(n\log n)$，其中 $n$ 为数组的长度。
  - 排序需要 $O(n\log n)$ 的时间，
  - 随后需要 $O(n)$ 时间来遍历。

- 空间复杂度：$O(n)$。因为要额外开辟一个数组。

![img](https://pic.leetcode-cn.com/1603690579-XxkRax-1365.%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97.png)


## 解法三：计数排序

- 注意到数组元素的值域为 $[0,100]$，所以可以考虑建立一个频次数组 $cnt(101, 0)$ ，$cnt[x]$ 表示数字 $x$ 出现的次数。
- 那么对于数字 $x$ 而言，小于它的数目就为 $cnt[0...x-1]$ 的总和。

**复杂度分析**
- 时间复杂度：$O(n + k)$，其中 $k$ 为值域大小。
   - 需要遍历两次原数组，同时遍历一次频次数组 $cnt$ 找出前缀和。
- 空间复杂度：$O(k)$。因为要额外开辟一个值域大小的数组。

## 解法四：二分 $O(nlogn)$

- 在排序数组里二分查找小于 $x$ 的第一个数，其 `下标+1` 即为所求。
- 注意判断 $x$ 是不是原数组中最小的数，如果是的话，那么比它小的数的个数为 $0$，需要特判。

**复杂度分析**
- 时间复杂度： $O(nlogn)$
  - 其中 $n$ 为 $nums$ 数组的长度。
- 空间复杂度：$O(n)$
