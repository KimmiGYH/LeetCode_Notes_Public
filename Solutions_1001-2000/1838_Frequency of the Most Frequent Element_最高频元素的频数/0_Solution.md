# 1838_Frequency of the Most Frequent Element_最高频元素的频数

## 解法一：前缀和 + 双指针 $O(n\log n)$

- 性质一：最高频的数一定可以为原数组中的数。

- 在最多操作 $K$ 次的情况下，最多可以将多少个数变成 $nums[i]$
- 如果要将所有数变成 $nums[i]$，则一定是将 $nums[i]$ 前面连续的一段变成 $nums[i]$
- 如何判断左端点 $j$ 下的 $nums[j]$ 到 右端点下的 $nums[i]$ 能在 $k$ 次之内操作变成 $nums[i]$ 呢？
- 答：其实就是求一下每个数与 $nums[i]$ 的差的和，总操作次数为：

    $(a[i] - a[j]) + (a[i] - a[j+1]) + ... + (a[i] - a[i])$

    $=(i - j + 1) * a[i] - (a[j] + a[j+1] + ... + a[i])$

**复杂度分析**

- 时间复杂度：$O(n\log n)$，其中 $n$ 是数组 $nums$ 的长度。排序数组的时间复杂度为 $O(n\log n)$，使用滑动窗口遍历目标值的时间复杂度为 $O(n)$。
- 空间复杂度：$O(\log n + n)$，排序使用的栈空间和前缀和数组


## 解法二：前缀和 + 二分 $O(n\log n)$

- 越往前走，变的数越多（需要操作的次数越多），每次需要进行的操作次数一定是单调递增的
- 所以二分一下左端点即可，求出最靠左的左端点
- 左端点越往左走，操作次数 $((LL)(j - mid + 1) * nums[j-1] - (s[j] - s[mid-1]) <= k)$ 会更接近于 $k$，所以一直可以在左半边二分（$r = mid$）

**复杂度分析**

- 时间复杂度：$O(n\log n)$，其中 $n$ 是数组 $nums$ 的长度。排序数组的时间复杂度为 $O(n\log n)$。
- 空间复杂度：$O(\log n + n)$，排序使用的栈空间和前缀和数组

