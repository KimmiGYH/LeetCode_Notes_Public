# 1743_Restore the Array From Adjacent Pairs_从相邻元素对还原数组

## 解法一：哈希表+无向树+DFS $O(n)$

[视频讲解](https://www.acwing.com/activity/content/problem/content/3458/)

```
示例 1：
输入：adjacentPairs = [[2,1],[3,4],[3,2]]
输出：[1,2,3,4]

g[2]: {1, 3}
g[1]: {2}
g[3]: {4, 2}
g[4]: {3}
```

- 相当于给我们一个链表，告诉我们这个链表的所有边，让我们把这个链表从前到后输出
- 给到的所有边是无向的
- 可以将链表看成是一棵无向树，只不过这棵树比较特殊，是一条链
- 遍历无向树，每次记录当前点 `u` 和它的父节点 `father`
- 如何找链表的某一端？两个端点被给出的次数是 $1$，中间所有点被给出的次数是 $2$，因此可以开哈希表，记录每个点出现次数。出现次数为 $1$ 的点就是端点，然后从端点做一遍树的遍历即可。
- 如何存储邻接表？可以用 $vector$ 来存，也可以用链表来存。

**复杂度分析**
- 时间复杂度：$O(n)$
  - 需要 $O(n)$ 的时间构造哈希表以找到出现一次的元素以及构造答案。
  - 构造答案时，也需要 $O(n)$ 的时间。
  - 故总时间复杂度为  $O(n)$。
- 空间复杂度：需要 $O(n)$ 的额外空间存储哈希表。

## 解法二：哈希表+图+BFS

- 也可以用 BSF 做
- 创建图的时候跟其他的题有点不一样，后面的写法跟大部分图都差不多
- 除了头和尾入度或者出度是 $1$，其他都是 $2$。所以头和尾，哪个加到队列里都行
- 加了个 $set$ 来判断某个点是否出现过
