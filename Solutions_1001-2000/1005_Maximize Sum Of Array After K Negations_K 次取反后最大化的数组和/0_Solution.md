# 1005_Maximize Sum Of Array After K Negations_K 次取反后最大化的数组和

首先来想，怎么使得数组和最大，肯定是正数越多越好，如果数组中有负数，肯定是要将其变为正数，此时数组中负数的个数和 $k$ 之间的大小关系并不确定，所以需要分情况来讨论。
- 当然最简单的情况就是负数的个数正好等于 $k$，这样只要将所有的负数都变成正数，就可以了。
- 若负数的个数大于 $k$，则肯定是选最小的 $k$ 个，也就是绝对值最大的 $k$ 个，这样翻转后和才能最大。
- 若负数个数小于 $k$，此时都翻转成了正数，但是 $k$ 值还没用完，还是要翻转，此时要分 $k$ 的奇偶来讨论，由于同一个位置可以多次翻转，若 $k$ 是偶数，则每次翻转后都可以翻回去，没有任何影响，而若 $k$ 是奇数，则必定会有一个非负数会被翻转，那肯定希望翻转的是最小的非负数，从而对结果影响最小。

## 解法一：sort 排序 $O(nlogn)$

- 给数组排序，这样所有的负数都在数组的前面，此时将前 $k$ 个负数翻转成正数
- 如果 $k$ 次还没用完，就要把数组里的非负数翻转
- 如果剩下 $k$ 次是偶数，那么还是原数
- 如果剩下 $k$ 次是奇数，就把最小的非负数取相反数，而和则是要减掉两倍的绝对值 `- 2 * minm`

时间复杂度：$O(nlogn)$。
空间复杂度：$O(n)$​。

## 解法二：桶排序 $O(n)$

- 观察题目给定的数据范围为 -100 ~ 100，所以，我们可以直接使用桶排序，来得更快。

时间复杂度为：$O(n+C)$，$n$ 为数组长度，$C$ 固定为 201。
空间复杂度为：$O(C)$。

## 解法三：优先队列/堆排序

- 使用一个优先队列来记录所有的负数的绝对值，再用一个变量 $minm$ 来记录数组中绝对值最小的数字
- 遍历数组，若遇到负数，则将其对应的**正数**排入优先队列，然后每次将这个数字(负数)加入结果 $res$，并且更新绝对值最小的数字。
- 之后进行遍历，遍历的次数是负数的个数和 $k$ 之间的较小值，每次取出绝对值最大的负数，将其绝对值乘以 $2$ 并加入到结果 $res$ 中。
- 循环结束后，$k$ 的值可能或奇或偶，当 $k$ 是偶数的时候（包括 $0$），直接返回 $res$，若是奇数的话，要减去 $minm$ 的 $2$ 倍，这是数组中绝对值最小的数。