# 树状数组蓝书讲解

附一个很棒的帖子：[树状数组学习笔记](https://www.acwing.com/blog/content/80/)

### 一、树状数组的概念

如果一个正整数 $x$ 的二进制表示为 $a_{k-1}a_{k-2}\cdots a_{2}a_{1}a_{0}$，其中等于 $1$ 的位是 $\left \{ a_{i_{1}}, a_{i_{2}}, \cdots, a_{i_{m}}\right \}$，则正整数 $x$ 可以被“二进制分解”成：

$x = 2^{i_{1}} + 2^{i_{2}} + \cdots + 2^{i_{m}}$

不妨设 $i_{1} > i_{2} > \cdots > i_{m}$，进一步地，区间 $[1,x]$ 可以分成 $\log_{}{x}$ 个小区间：

1. 长度为 $2^{i_{1}}$ 的小区间 $\left [1, 2^{i_{1}} \right]$
2. 长度为 $2^{i_{2}}$ 的小区间 $\left [2^{i_{1}} + 1, 2^{i_{1}} + 2^{i_{2}} \right]$
3. 长度为 $2^{i_{3}}$ 的小区间 $\left [2^{i_{1}} + 2^{i_{2}} + 1, 2^{i_{1}} + 2^{i_{2}} + 2^{i_{3}}\right]$

    $\cdots$

m. 长度为 $2^{i_{m}}$ 的小区间 $\left [2^{i_{1}} + 2^{i_{2}} + \cdots + 2^{i_{m-1}} + 1, 2^{i_{1}} + 2^{i_{2}} + \cdots + 2^{i_{m}}\right]$

这些小区间的共同特点是：若区间结尾为 $R$，则区间长度就等于 $R$ 的“二进制分解”下最小的 $2$ 的次幂，即 $lowbit(R)$。

例如 $x = 7 = 2^{2} + 2^{1} + 2^{0}$，区间 $[1, 7]$ 可以分成 $[1, 4]$、$[5, 6]$ 和 $[7, 7]$ 三个小区间，长度分别是 $lowbit(4) = 4$、$lowbit(6) = 2$ 和 $lowbit(7) = 1$。

树状数组(Binary Indexed Trees) 就是基于上述思想的数据结构，期基本用途是维护序列的前缀和。对于给定的序列 $a$，我们建立一个数组 $c$，其中 $c[x]$ **保存序列 $a$ 的区间 $[x - lowbit(x) + 1, x]$** 中所有数的和，即 ${\textstyle \sum_{i=x-lowbit(x)+1}^{x}a[i]}$。

事实上数组 $c$ (图中是用 $t$ 表示) 可以看作一个如下图所示的树形结构，途中最下边一行是 $N$ 个叶节点（$N = 16$），代表数值 $a[1\sim N]$。该结构满足以下性质：

1. 每个内部节点 $c[x]$ 保存以它为根的子树中所有叶节点的和。
2. 每个内部节点 $c[x]$ 的子节点个数等于 $lowbit(x)$ 的位数。
3. 除树根外，每个内部节点 $c[x]$ 的父节点是 $c[x+lowbit(x)]$。
4. 树的深度为 $O(\log_{}{N})$。

### 二、树状数组支持的两个操作

树状数组支持的基本操作有两个，第一个操作是 **查询前缀和**，即序列 $a$ 第 $1\sim x$ 个数的和。按照我们刚才提出的方法，应该求出 $x$ 的二进制表示中每个等于 $1$ 的位，把 $[1,x]$ 分成 $O(\log_{}{n})$ 个小区间，而每个小区间的区间和都已经保存在数组 $c$ 中。

树状数组支持的第二个基本操作是 **单点增加**，意思是给序列中的一个数 $a[x]$ 加上 $v$，同时正确维护序列的前缀和。根据上面给出的树形结构和它的性质，只有节点 $c[x]$ 及其所有祖先节点保存的 “区间和” 包含 $a[x]$，而任意一个结点的祖先至多只有 $O(\log_{}{N})$ 个，我们逐一对它们的 $c$ 值进行更新即可。

为了简便，比较一般的初始化方法是：直接建立一个全为 $0$ 的数组 $c$，然后对每个位置 $x$ 执行 $add(x, a[x])$，就完成了对原始序列 $a$ 构造树状数组的过程，时间复杂度为 $O(N\log_{}{N})$。

**树状数组模板**

```cpp
int n;
vector<int> tr;

int lowbit(int x) {
    return x & -x;
}

int query(int x) {
    int presum = 0;
    for (int i = x; i; i -= lowbit(i))
        presum += tr[i];
    return presum;
}

void add(int x, int v) {
    for (int i = x; i <= n; i += lowbit(i))
        tr[i] += v;
}
```