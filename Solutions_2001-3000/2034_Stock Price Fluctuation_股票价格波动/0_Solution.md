# 2034_Stock Price Fluctuation_股票价格波动

## 解法一：multiset + hashmap

- 用一个 $multiset$（可重集合）来记录当前股票的价格
- 每次更新时，如果时间存在对应的股票价格，就删除原先的价格
  - 删的时候用 `s.erase(s.find(hash[t]))`，$hashmap$ 中找到时间对应的价格，然后在 $multiset$ 中找到价格对应的迭代器，然后把该迭代器删掉
- 更新 $multiset$（股票价格）
- 维护最新的股票的价格以及时间戳
- $multiset$ 数据结构自动排序，最左/最右，即为：最小/最大

**复杂度分析**
- 时间复杂度：
  - 初始化的时间复杂度是 $O(1)$，更新操作、返回股票最高价格操作和返回股票最低价格操作的时间复杂度是 $O(\log n)$，返回股票最新价格操作的时间复杂度是 $O(1)$，其中 $n$ 是更新操作的次数。
  - 更新操作需要更新最大时间戳、哈希表和有序集合，更新最大时间戳和哈希表需要 $O(1)$ 的时间，更新有序集合需要 $O(\log n)$ 的时间。
  - 返回股票最高价格操作和返回股票最低价格操作分别需要在有序集合中寻找最大值和最小值，需要 $O(\log n)$ 的时间。
  - 返回股票最新价格操作需要在哈希表中得到最大时间戳对应的股票价格，需要 $O(1)$ 的时间。

- 空间复杂度：$O(n)$，其中 $n$ 是更新操作的次数。
  - 空间复杂度主要取决于哈希表和有序集合，哈希表和有序集合中存储的元素个数不会超过更新操作的次数。


## 解法二：hashmap + 2个 priority_queue

- 删除过期价格不一定要在更新操作中完成，而是可以在返回股票最高价格操作和返回股票最低价格操作中完成，即延迟删除。
- 为了实现延迟删除，需要维护两个优先队列用于存储股票价格和时间戳，分别基于大根堆和小根堆实现
  - 大根堆的堆顶元素对应股票最高价格
  - 小根堆的堆顶元素对应股票最低价格
- 对于更新操作，使用 $maxtime$ 更新最大时间戳，将 $timestamp$ 和 $price$ 存入哈希表，并将 $(price,timestamp)$ 分别加入两个优先队列。
- 对于返回股票最新价格操作，从哈希表中得到最大时间戳对应的股票价格并返回。

- 对于返回股票**最高价格**操作，每次从最高价格队列的队首元素中得到价格和时间戳，并从哈希表中得到该时间戳对应的实际价格，如果队首元素中的价格和实际价格不一致，则队首元素为过期价格，将队首元素删除，重复该操作直到队首元素不为过期价格，此时返回队首元素中的价格。

- 对于返回股票**最低价格**操作，每次从最低价格队列的队首元素中得到价格和时间戳，并从哈希表中得到该时间戳对应的实际价格，如果队首元素中的价格和实际价格不一致，则队首元素为过期价格，将队首元素删除，重复该操作直到队首元素不为过期价格，此时返回队首元素中的价格。

**复杂度分析**

- 时间复杂度：
  - 初始化的时间复杂度是 $O(1)$，更新操作、返回股票最高价格操作和返回股票最低价格操作的**均摊**时间复杂度是 $O(\log n)$，返回股票最新价格操作的时间复杂度是 $O(1)$，其中 $n$ 是更新操作的次数。
  - 更新操作需要更新最大时间戳、哈希表和两个优先队列，更新最大时间戳和哈希表需要 $O(1)$ 的时间。
  - 更新操作、返回股票最高价格操作和返回股票最低价格操作中，每个元素分别在两个优先队列中添加和删除一次，平均需要 $O(\log n)$ 的时间。
  - 返回股票最新价格操作需要在哈希表中得到最大时间戳对应的股票价格，需要 $O(1)$ 的时间。

- 空间复杂度：$O(n)$，其中 $n$ 是更新操作的次数。
  - 空间复杂度主要取决于哈希表和优先队列，哈希表和每个优先队列中存储的元素个数不会超过更新操作的次数。

## 写法三：hashmap + 优先队列 + template

[参考 Qian 的帖子](https://leetcode-cn.com/problems/stock-price-fluctuation/solution/c-ha-xi-biao-you-xian-dui-lie-by-qian2-ff8c/)
