# 10_知识点：回溯 Backtracking

总结：
https://programmercarl.com/周总结/20201030回溯周末总结.html
https://programmercarl.com/周总结/20201107回溯周末总结.html#周一


![题目分类](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)

### 知识点 1：回溯剪枝

优化之后的$for$循环是：
```cpp
for (int i = start; i <= n + 1 - (k - path.size()); i++)
```

- `path.size()` ： 已经找的个数
- `k-path.size()` ：还需找的个数
- `【x, n】`的数组长度起码应该是 `k - path.size()` 才有继续搜索的可能， 那么就有 `n-x+1 >= k-path.size()`， 解方程得 `x <= n+1 - (k-path.size())`, 而且这个 `x` 是可以从起点 `s` 往下搜的 也就是 `for(i = s; i <= x的最大值; i++)`，这里的 `x` 的最大值 `n + 1 - (k - path.size())`

### 知识点 2：题目类型总结

- `39题` vs `77题`和`216题`
  39题是讲解的组合总和问题，和以前的组合问题还都不一样。
  39题和 77题 与 216题的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。

- `39题` vs `40题`：
  40题数组 `candidates` 的元素是有重复的，而 39题是无重复元素的数组 `candidates`
  40题 `candidates` 中的每个数字在每个组合中只能使用一次。
  40题和 39题要求一样，解集不能包含重复的组合。

- `46题` vs `47题`
  全排列，区别在于后者元素有重复。
  排列问题都要写：
  ```cpp
  if (used[i] == true)
      continue; // path里已经收录的元素，直接跳过
  ```
  `47题`树层去重还需添加：
  ```cpp
  if (i && nums[i] == nums[i-1] && used[i-1] == false)
      continue; // 树层去重
  ```

### 知识点 3：性能分析

##### 子集问题分析：$O(n × 2^n)$

- 时间复杂度：  $O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为 $O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。

- 空间复杂度：  $O(n)$，递归深度为 $n$，所以系统栈所用空间为 $O(n)$，每一层递归所用的空间都是常数级别，注意代码里的`res`和`path`都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为 $O(n)$。


##### 排列问题分析：$O(n!)$

- 时间复杂度：  $O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为$n$，第二层每一个分支都延伸了 $n-1$ 个分支，再往下又是 $n-2$ 个分支，所以一直到叶子节点一共就是 $n * (n-1) * (n-2) * ..... 1 = n!$。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：`res.push_back(path)`），该操作的复杂度为 $O(n)$。所以，最终时间复杂度为：$n * n!$，简化为 $O(n!)$。

- 空间复杂度：  $O(n)$，和子集问题同理。

##### 组合问题分析：$O(n × 2^n)$

- 时间复杂度：  $O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。

- 空间复杂度：  $O(n)$，和子集问题同理。


***一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！***

## 组合

- 77，组合＋DFS＋回溯＋剪枝优化
- 216，组合＋DFS＋回溯＋剪枝优化，位运算
- 17，组合＋DFS＋回溯
- 39，组合＋DFS＋回溯＋剪枝，元素不重复，可以反复取
- 40，组合＋DFS＋回溯＋剪枝，元素有重复，树枝可重复取，树层去重

## 分割

- 131.分割回文串，分割＋DFS＋回溯＋DP（DP未做）
- 93.复原IP地址，分割＋DFS＋回溯

## 子集

- 78，子集＋DFS＋回溯（不剪枝，遍历整棵树）
- 90，子集＋DFS＋回溯，元素有重复，树枝可重复取，树层去重，40题为基础
- 491，不能排序，子集＋DFS＋回溯＋哈希表

## 排列

- 46，全排列＋DFS＋回溯
- 47，全排列＋DFS＋回溯，树层去重
