# 位运算更新中

## 1、为什么一个整数的负数是补码？

### 1.1 原码、反码、补码

举例：比如十进制数 $10$，其二进制数为 $1010$
```
原码：0...01010
反码：1...10101
补码：1...10110 （补码为反码加1）
```

int $32$ 位：

1：`0000000000...01`

2：`0000000000...10`

3：`0000000000...11`


### 1.2 补码如何计算
```
1 + x = 00000000000000000000000000000000
1 + 1111111111...1111 = 0000000000...00
2 + 1111111111...1110 = 0000000000...00
x +          ?        = 0000000000...00
```
$\mathbf{? = ~x + 1} $

比如：

- $2$ 的补码，是将 $2$ 的二进制数先取反得`1111111111...01`，再加`1`，得`1111111111...10`

- 验证 $2$ 加上 $2$ 的补码是不是等于零？是的。
    
    - $2$ 的原码：`0000000000...10`
    - $2$ 的补码：`1111111111...10`
    - 加起来得：`0000000000...00`

所以，**一个整数的负数是补码。**


例子：程序验证 $10$ 的补码，补码为 反码加$1$，即 $\sim x + 1$。
```cpp
#include <iostream>

using namespace std;

int lowbit(int x)
{
    return x & -x;
}

int main()
{
    int n = 10;
    unsigned int x = -n;
    for (int i = 31; i >= 0; i--)  cout << (x >> i & 1);
    // Output: 10的补码为：11111111111111111111111111110110
    cout << endl;
    return 0;
}
```

## 2、$lowbit(x)$

### 2.1 $lowbit(x)$ 的作用

- $lowbit(x)$ 操作返回 $x$ 的最后一位 $1$

    - $x = {1010}_2$，那么 $lowbit(x)$ 返回 ${10}_2 $，即 $lowbit(x) = 10$

    - $x = {101000}_2$，那么 $lowbit(x)$ 返回 ${1000}_2 $，即 $lowbit(x) = 1000$

- 第一步：先把第 $k$ 位移到最后一位：$n$ 右移 $k$ 位：$n \gg k$ 

- 第二步：看个位是几？$x \And 1$

- 所以最后写成：$\color{#FF0000}{n \gg k \And  1}$

例子：将 $10$ 的二进制数输出：得到 $1010$

```cpp
#include <iostream>
#include <string.h>

using namespace std;

int main()
{
    int n = 10;
    
    for (int k = 3; k >= 0; k--)  cout << (n >> k & 1);
    
    return 0;
}
// Output: 1010
```

### 2.2 $lowbit(x)$ 的实现

- $lowbit(x)$ 实现的时候就是 $\color{#FF0000}{x \And-x}$

- 首先，一个整数的负数是（原数的）补码。补码是取反$+1$，即 $\color{#0000FF}{-x = \sim x + 1}$

- 所以，$\color{#FF0000}{x \And-x}$ = $\color{#0000FF}{x \And (\sim x + 1)}$

### 2.3 为什么 $lowbit(x)$ 可以得到 $x$ 的最后一位？

![位运算_lowbit.png](https://cdn.acwing.com/media/article/image/2021/02/02/41956_38156e8c64-位运算_lowbit.png) 



### 2.4 $lowbit$ 的应用：可以统计 $x$ 中 $1$ 的个数

**思路**：就是每一次把 $x$ 的最后一位 $1$ 减掉，即 $x - lowbit(x)$，只需要算下减多少次，减多少次就有多少个 $1$

**题目：位运算 —— 模板题** [AcWing 801. 二进制中1的个数](https://www.acwing.com/activity/content/problem/content/835/1/)

```cpp
n >> k & 1;         //求x的第k位数字
lowbit(n) = n & -n; //返回x的最后一位1

int solve(uint32_t n) {
    int res = 0;
    while (n)  n -= n & -n, res++;
    return res;
}
```