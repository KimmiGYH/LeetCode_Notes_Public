# 187_Repeated DNA Sequences_重复的DNA序列

## 解法一：哈希表 $O(n)$

```cpp
/*Ex1:
AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT

AAAAACCCCC
     CCCCCAAAAA
          AAAAACCCCC
                CCCCCAAAAA
*/
```
- 用哈希表记录所有长度是 $10$ 的子串的个数。
- 从前往后扫描，当子串出现第二次时，将其记录在答案中。

**复杂度分析**
- 时间复杂度：$O(NL)$，其中 $N$ 是字符串 $s$ 的长度，$L=10$ 即目标子串的长度。
- 空间复杂度：$O(NL)$。


## 解法二：字符串哈希

- 子串长度为 $10$，因此上述解法的计算量为 $10^{6}$。
- 若题目给定的子串长度大于 $100$ 时，加上生成子串和哈希表本身常数操作，那么计算量将超过 $10^{7}$，会 $TLE$。
- 因此一个能够做到严格 $O(n)$ 的做法是使用「字符串哈希 + 前缀和」。
- 具体做法为，我们使用一个与字符串 $s$ 等长的哈希数组 `h[]`，以及次方数组 `p[]`。
- 由字符串预处理得到这样的哈希数组和次方数组复杂度为 $O(n)$。当我们需要计算子串 $s[i...j]$ 的哈希值，只需要利用前缀和思想 $h[j] - h[i - 1] * p[j - i + 1]$ 即可在 $O(1)$ 时间内得出哈希值（与子串长度无关）。
- 到这里，还有一个小小的细节需要注意：如果我们期望做到严格 $O(n)$，进行计数的「哈希表」就不能是以 $string$ 作为 $key$，只能使用 $int$，这里是 `unsigned long long`（也就是 hash 结果本身）作为 $key$。

**复杂度分析**
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

## 解法三：哈希表 + 滑动窗口 + 位运算

![img](https://pic.leetcode-cn.com/1633671302-NcrcuY-asfdas.png)

由于 $s$ 中只含有 $4$ 种字符，我们可以将每个字符用 $2$ 个比特表示，即：

- $A$ 表示为二进制 $00$；
- $C$ 表示为二进制 $01$；
- $G$ 表示为二进制 $10$；
- $T$ 表示为二进制 $11$。

如此一来，一个长为 $10$ 的字符串就可以用 $20$ 个比特表示，而一个 $int$ 整数有 $32$ 个比特，足够容纳该字符串，因此我们可以将 $s$ 的每个长为 $10$ 的子串用一个 $int$ 整数表示（只用低 $20$ 位）。

注意到上述字符串到整数的映射是一一映射，每个整数都对应着一个唯一的字符串，因此我们可以将方法一中的哈希表改为存储每个长为 $10$ 的子串的整数表示。


如果我们对每个长为 $10$ 的子串都单独计算其整数表示，那么时间复杂度仍然和方法一一样为 $O(NL)$。为了优化时间复杂度，我们可以用一个大小固定为 $10$ 的滑动窗口来计算子串的整数表示。

设当前滑动窗口对应的整数表示为 `x`，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：

- 滑动窗口向右移动一位：`x = x << 2`，由于每个字符用 $2$ 个比特表示，所以要左移 $2$ 位；
- 一个新的字符 $ch$ 进入窗口：`x = x | bin[ch]`，这里 $bin[ch]$ 为字符 $ch$ 的对应二进制；
- 窗口最左边的字符离开窗口：`x = x & ((1 << 20) - 1)`，由于我们只考虑 $x$ 的低 $20$ 位比特，需要将其余位置零，即 `&` 与上  `(1 << 20) - 1`。

将这三步合并，就可以用 $O(1)$ 的时间计算出下一个子串的整数表示，即 `x = ((x << 2) | bin[ch]) & ((1 << 20) - 1)`。

**复杂度分析**

- 时间复杂度：$O(N)$，其中 $N$ 是字符串 $s$ 的长度。
- 空间复杂度：$O(N)$。
