# 704. Binary Search (Easy)

二分查找算法，用于在已排序的数组 `nums` 中查找目标整数的第一个出现位置。

该算法通过维护两个指针 `l` 和 `r`，分别表示搜索范围的左右边界。在每次循环迭代中，算法计算当前搜索范围的中点 mid，并将 `nums[mid]` 与目标值进行比较。如果 `nums[mid]` 大于或等于目标值，则将搜索范围缩小到左侧，更新 `r = mid`；否则将搜索范围缩小到右侧，更新 `l = mid + 1`。循环继续直到搜索范围缩小到单个元素。

循环结束后，如果目标值在数组中被找到，则算法返回目标值的第一个出现位置，即 `r`。否则，函数返回 `-1` 表示目标值未在数组中找到。

需要注意的是，该算法假定输入数组以非递减顺序排序，并且能够找到目标值在数组中的第一个出现位置。如果数组未排序或目标值不存在于数组中，则算法行为是未定义的。

## 比较这两种解法

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if (nums[r] != target) return -1;
        return r;
    }
};
```

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size(); //为了覆盖到
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) r = mid;
            else l = mid + 1;
        }
        return -1;
    }
};
```

二分查找算法的实现方式有很多种，不同的实现方式可能会对左右边界的取值方式有所不同。

- 一般来说，**左闭右闭**区间的二分查找算法比较容易实现，因为它的搜索区间是一个闭区间 `[l, r]`，左右边界的取值比较直观。在初始化右边界 `r` 的值时，我们需要减去 $1$，因为右边界是包括在搜索区间中的，如果不减去 $1$ 的话，就会出现越界访问数组的问题。在每次迭代中，我们将搜索区间的右边界移动到中间位置的左边，即 `r = mid`，这样可以保证搜索区间的右边界仍然在有效的数组下标范围内。

- 而**左闭右开**区间的二分查找算法相对来说比较灵活，因为它可以适用于更多种情况。在初始化右边界 `r` 的值时，我们不需要减去 $1$，因为右边界是不包括在搜索区间中的。在每次迭代中，我们需要根据目标元素和中间位置的大小关系，将搜索区间的左右边界缩小，以便于最终找到目标元素的位置。如果目标元素比中间位置的元素小，那么我们就将搜索区间的右边界设为中间位置的下标，即 `r = mid`；如果目标元素比中间位置的元素大，那么我们就将搜索区间的左边界设为中间位置的下标加一，即 `l = mid + 1`。

总之，不同的左右边界取值方式适用于不同的情况，在实际应用中需要根据具体问题来选择合适的实现方式。


同理，也可以比较这两种方式，check的是左半边：

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l < r)
        {
            int mid = l + r + 1>> 1;
            if (nums[mid] <= target) l = mid; // 另一种写法，check的左半边
            else r = mid - 1;
        }
        if (nums[r] != target) return -1; 
        return r;
    }
};
```

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.empty()) return -1;
        int l = -1, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) l = mid;
            else r = mid - 1;
        }
        return -1;
    }
};
```

这两种代码都在实现二分查找，但它们使用的搜索区间有所不同。第一个代码使用左闭右闭区间（即 `[l, r]`），而第二个代码使用左开右闭区间（即 `(l, r]`）。这导致了在更新边界时有一些细微的差别。让我们逐个分析这两种代码。

### 第一段代码

这段代码使用左闭右闭区间 `[l, r]`。初始化时，`l = 0` 和 `r = nums.size() - 1`，因此搜索区间包含整个数组。在循环中，我们计算中间值 `mid`，并根据 `nums[mid]` 和 `target` 的关系来更新搜索区间的边界。由于区间是左闭右闭的，当我们缩小区间时，新的边界依然包含在搜索区间内。这意味着当 `l` 和 `r` 相等时，我们仍在搜索一个元素，这就是为什么循环条件是 `l < r`。当循环结束时，我们需要检查 `nums[r]` 是否等于 `target`，如果是，则返回 `r`，否则返回 `-1`。

### 第二段代码

这段代码使用左开右闭区间 `(l, r]`。初始化时，`l = -1` 和 `r = nums.size() - 1`，这样搜索区间仍然包含整个数组，但左端点不包含。在循环中，我们同样计算中间值 `mid`，并根据 `nums[mid]` 和 `target` 的关系来更新搜索区间的边界。由于区间是左开右闭的，当我们缩小区间时，新的边界依然包含在搜索区间内，但左端点不包含。这意味着当 `l + 1 == r` 时，我们仍在搜索一个元素，这就是为什么循环条件是 `l < r`。当循环结束时，我们直接判断 `nums[mid]` 是否等于 `target`，如果是，则返回 `mid`，否则返回 `-1`。

总的来说，左闭右闭区间和左开右闭区间的主要区别在于如何处理搜索区间的边界。在左闭右闭区间中，边界包含在搜索区间内，而在左开右闭区间中，左边界不包含在搜索区间内。这导致了在更新边界和循环条件时有一些细微的差别。从实现上看，这两种方法都是正确的，选择哪种方法主要取决于个人编码习惯。