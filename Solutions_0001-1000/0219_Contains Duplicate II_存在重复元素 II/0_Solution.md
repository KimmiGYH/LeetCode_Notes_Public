# 219. Contains Duplicate II_存在重复元素 II

## 解法一：哈希表

- 我们只关心离 `i` 最近的一个数，离 `i` 最近就意味着 `j` 和 `i` 的差越小，就越有可能满足要求。
- 用哈希表存一下每个数的位置是什么。
- 当枚举 $a_{i}$ 时，我们需要看一下前面那个 $a_{i}$ 的最后一个数的位置，值相同的数的两个位置之差是否 $\le k$

    ```c++
    // 如果x在之前出现过，且i减去x之前出现的最后一次位置hash[x]小于等于k的话
    if (hash.count(x) && i - hash[x] <= k)  return true;
    ```

- 之后需要更新一下位置 $hash[a_{i}] = i$。

**复杂度分析**
- 时间复杂度：$O(n)$
- 空间复杂度：$O(k)$

## 解法二：维护哈希表中只有 $k$ 个元素

- 这道题可以维护⼀个只有 $k$ 个元素的哈希表，每次只需要判断这个哈希表⾥⾯是否存在这个元素即可。
- 如果存在就代表重复数字的下标差值在 $k$ 以内。
- 哈希表的⻓度如果超过了 $k$ 以后就删除掉 `nums[i-k]` 的那个元素，这样⼀直维护哈希表⾥⾯只有 $k$ 个元素。

**复杂度分析**：
- 时间复杂度：$O(n)$
  - 查找表是哈希表，每次操作都是 $O(1)$，整体复杂度是 O(n)。
- 空间复杂度：$O(k)$



