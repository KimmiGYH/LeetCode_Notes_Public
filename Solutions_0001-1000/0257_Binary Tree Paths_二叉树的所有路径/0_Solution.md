# 257. Binary Tree Paths_二叉树的所有路径 (Easy)



**(递归回溯) O(n^2)**

1. 从根结点开始递归遍历，每个结点仅遍历一次，遍历时需要记录当前路径。

2. 若发现当前结点没有左右儿子，则当前结点为叶子结点，将当前路径加入答案。

##### 时间复杂度

- 每个结点仅遍历一次，遍历时维护路径所需要的平均时间也和遍历时间成正比。

- 最坏情况下，每条路径需要 $O(n)$ 的时间存放，共有 $O(n)$ 个叶子节点，故总时间复杂度为 $O(n^2)$，可以参考评论里的图。



最坏情况会达到 $O(n^2)$，考虑一个完全左偏的树。

             1
            / \
           2   3
          / \
         4   5
        / \
       6   7
      / \
     8   9
    ...
叶子节点的路径长度分别是 2，3，4，5，……，共有 $n / 2$ 个叶子节点，所以时间复杂度达到了 $O(n^2)$。


## 解法一：递归

1. 找到叶子节点，就开始结束的处理逻辑。
什么时候算是找到了叶子节点？ 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。
```cpp
if (cur->left == NULL && cur->right == NULL) {
    终止处理逻辑
}
```

2. 回溯和递归是一一对应的，有一个递归，就要有一个回溯
```cpp
if (cur->left) {
    traversal(cur->left, path, result);
    path.pop_back(); // 回溯
}
if (cur->right) {
    traversal(cur->right, path, result);
    path.pop_back(); // 回溯
}
```
