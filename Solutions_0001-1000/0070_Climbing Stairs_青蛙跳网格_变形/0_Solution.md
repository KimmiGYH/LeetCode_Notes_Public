# 思考题：如果是任意步数呢？有多少种可能呢？

原题描述：
假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

我们用`F(N)=F(N-1)+F(N-2)`的动态规划思想做完了。用一个数组遍历一遍复杂度为`O(N)`.

**最后留下了一道思考题:**

如果我们可以走任意步，那么走到第`N`阶台阶一共有多少种可能呢？
我们不妨仍然假设`F(N)`表示走到第N阶台阶的可能数，显然有

F(1)=1 1=1

F(2)=2 2=1+1, 2=2

F(3)=4 3=1+2, 3=1+1+1, 3=2+1, 3=3

F(4)=8 4=1+3, 4=1+1+2, 4=2+2, 4=1+2+1, 4=1+1+1+1, 4=2+1+1, 4=3+1, 4=4

由于我们可以走任意步，显然可以从 `[0,1,2,3,4,......,N-1]` 中无论哪一阶直接走到第`N`阶，
有`F(N)=F(0)+F(1)+F(2)+F(3)+.......+F(N-1)`。 其中`F(0)=1`，表示直接从`0`阶直接走`N`阶到达第`N`阶。

且我们有初始值`F(1)=1`, `F(2)=2`

于是：

这样的复杂度是`O(N^2)`

```cpp
int climbStairs(int N)
{
    vector<int>dp(N+1, 0);
    dp[1] = 1;
    dp[2] = 2;
    for(int i = 3; i <= N; ++i)
    {
        int sum_of_before=0;
        for(int j = 1; j < i; ++j)
        sum_of_before = sum_of_before + dp[j];
        dp[i] = sum_of_before;
    }
    return dp[N];
}
```

**优化：**

我们可以在循环外定义一个`sum`变量，存储迄今为止前`i-1`个元素的和，每次求新的元素时更新它。这样复杂度就变成了`O(N)`

```cpp
int climbStairs(int N)
{
    vector<int>dp(N+1, 0);
    dp[1] = 1;
    dp[2] = 2;
    int sum = 3;
    for(int i = 3; i <= N; ++i)
    {
        dp[i] = sum + 1;
        //sum = sum + dp[i];即是说sum=sum+sum+1=2sum+1
        sum = 2 * sum + 1;
    }
    return dp[N];
}
```

**通式：**

当我们在上面的优化中发现`sum=2sum+1`这个表达式的时候，我们就应该敏感的感觉到这个问题一定存在通式。

//`+1`表示`F(0)`, 表示直接从`0`阶直接走`N`阶到达第`N`阶

F(1)=1

F(2)=2 F(2)=F(1)+1 = 1+1=2

F(3)=4 F(3)=F(1)+F(2)+1 = 1+2+1=4

F(4)=8 F(4)=F(1)+F(2)+F(3)+1 =1+2+4+1=8

F(5)=16 F(5)=F(1)+F(2)+F(3)+F(4)+1 =1+2+4+8+1=16

F(6)=32 F(6)=F(1)+F(2)+F(3)+F(4)+F(5)+1 =1+2+4+8+16+1=32

……

F(N)=2^(N-1) F(N)=(1+2+4+8+…+2^(N-2))+1=2^(N-1)-1+1=2^(N-1)

于是我们得到了通式`F(N)=2^(N-1)`,复杂度于是变成了`O(1)`

```cpp
int climbStairs(int N)
{
    return power(2, N-1);
}
```

看到`2^(N-1)`这个式子，我突然想到高中的排列组合，其实一开始我就觉的走楼梯这种题其中有排列组合的味道，你一共有那么多数可以加起来等于你要走到的台阶，你要做的就是把他进行排列和组合。

```cpp
C(0,n) + C(1,n) + C(2,n) + ... + C(n,n) = 2^n
```

仔细想想其实我们就是在`0`到`N-1`个阶梯里挑一个起点直接到第`N`阶台阶

于是

```cpp
F(N)=C(0,n-1) + C(1,n-1) + C(2,n-1) + ... + C(n-1,n-1) = 2^(n-1)
```

其中`C(m, n-1)`的意义我仔细想了想，觉得应该是指`0`到`n-1`阶挑一个台阶为起点，走`m+1`次的所有可能的次数。说起来有点复杂。我们拿`F(5)`举例：

F(5) 走5次只有一种选择11111 C(4,4)

F(5) 走4次只有4种选择2111，1211，1121，1112，C(3,4)

F(5) 走3次只有6种选择311，131，113，221，212，122，C(2,4)

F(5) 走2次只有4种选择41，14，32，23，C(1,4)

F(5) 走1次只有1种选择05，C(0,4)

再进一步思考，其实，之前的爬楼梯的题，每次只能爬1或2步，`F(N) = F(N-1) + F(N-2)`，且`F(1)=1`, `F(2)=2`,其实就是斐波那契数列，而斐波那契数列其实是有通项公式。

于是，我大胆的推测一下，其实类似这种爬楼梯的题，都可以推导出数学上的通项公式。
以上。

作者：Frefff
链接：https://leetcode-cn.com/problems/climbing-stairs/solution/si-kao-ti-ru-guo-shi-ren-yi-bu-shu-ni-you-duo-shao/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
