# 491_Non-decreasing Subsequences_递增子序列

## 解法一：DFS＋回溯＋哈希表

在 [90.子集II] 中我们是通过排序，再加一个标记数组来达到去重的目的。

而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。

示例：用[4, 7, 6, 7]这个数组来举例，抽象为树形结构如图：

![图解](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png)

### 回溯三部曲

- 递归函数参数

本题求子序列，很明显一个元素不能重复使用，所以需要`startIndex`，调整下一层递归的起始位置。

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking(vector<int>& nums, int startIndex)
```

- 终止条件

本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和[回溯算法：求子集问题]一样，可以不加终止条件，`startIndex`每次都会加1，并不会无限递归。
但本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：
```cpp
if (path.size() >= 2) {
    result.push_back(path);
    // 注意这里不要加return，因为要取树上的所有节点
}
```

- 单层搜索逻辑

在图中可以看出，**同一父节点下的同层上使用过的元素就不能再使用了**

需要注意的点，`unordered_set<int> S` 是记录本层元素是否重复使用，新的一层`uset`都会重新定义（清空）


##### 复杂度分析

**时间复杂度**

- 最坏情况下，每个数字都有两个选择，选或者不选，故总共可能有 $2^n$个答案，累计答案需要 $O(n)$ 的时间，故总时间复杂度为 $O(n*2^n)$

**空间复杂度**

- 递归需要$O(n)$ 的系统栈空间，答案需要$O(n*2^n)$ 的空间。
