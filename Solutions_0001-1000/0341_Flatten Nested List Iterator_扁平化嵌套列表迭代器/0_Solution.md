# 341. Flatten Nested List Iterator_扁平化嵌套列表迭代器 (Medium)



## 解法一：递归 (dfs) O(n)

为了方便处理，在初始化时我们先递归遍历整个链表中的所有整数，将它们存入`vector<int>`中。

`dfs`时，如果遇到整数，则直接存入数组中；如果遇到嵌套链表，则递归遍历之。

然后对于 `next()` 函数，我们依次返回 `vector<int>` 中的每个数；对于 `hasNext()` 函数，我们判断是否已经遍历完整个 `vector<int>`；



**时间复杂度分析：**

初始化时链表中的每个整数仅被遍历一次，所以初始化的时间复杂度是 `O(n)`；

`next()` 函数每次返回一个数，时间复杂度是 `O(1)`；

`hasNext()` 函数只有一个判断，时间复杂度也是 `O(1)。



## 解法二：迭代 - 栈



当调用 `hasNext` 时我们将栈顶元素变为下一个要访问的整数，初始化时将迭代器**逆序**压入栈中，这样可以保证栈顶的迭代器为输入数组的第一个迭代器。



可以用 `rbegin`、`rend` **反向迭代器**，在构造时仅仅扒一层皮就 **逆向** 堆入栈中，在用户调用 `hasNext` 时才做深入扒皮搜索。



**时间复杂度：**
时间复杂度与上面的算法相同，不过空间复杂度会降低。考虑 `[1,[1,[1,[1,...,]]]]` 这种情况，那么栈中的迭代器数量最大为`2`，降低了很多空间。