# 841_Keys and Rooms_钥匙和房间 (Medium)

[DFS 花花酱](https://www.bilibili.com/video/av31292134/)
[BFS Sheep](https://www.bilibili.com/video/av498014775/)

## 解法一：(宽度/深度优先遍历) $O(V+E)$

1. 我们从 `0` 号房间开始宽度或深度优先遍历，房中的钥匙看做是相邻的有向边。

2. 用 `visited` 数组记录，保证每个点最多只进入一次。

**时间复杂度：**

- 每个点最多只进入一次，每条边遍历一次，故时间复杂度为 $O(V+E)$。

**空间复杂度：**

- 使用 `visited` 数组和一个队列（深度优先遍历需要用系统栈），故空间复杂度为 $O(n)$。

## BFS 有向图的遍历 $O(V+E)$

- 先用 `BFS` 来遍历，使用一个 `HashSet` 来记录访问过的房间，先把 `0` 放进去，然后使用 `queue` 来辅助遍历，同样将 `0` 放入。

- 之后进行 `BFS` 遍历，取出队首的房间，然后遍历其中的所有钥匙，若该钥匙对应的房间已经遍历过了，直接跳过，否则就将钥匙加入 `HashSet。`

- 如果 `HashSet` 中的钥匙数已经等于房间总数了，表示所有房间已经访问过了，返回 `true`；否则就将钥匙加入队列继续遍历。

- 最后遍历结束后，就看 `HashSet` 中的钥匙数是否和房间总数相等即可。
