# 47. Permutations II_全排列 II

## 解法一：回溯 $O(n!)$

由于有重复元素的存在，这道题的枚举顺序和 [46. Permutations](https://leetcode.com/problems/permutations/) 不同。

1. 先将所有数从小到大排序，这样相同的数会排在一起；

2. 从左到右依次枚举每个数，每次将它放在一个空位上；

3. 对于相同数，我们人为定序，进行剪枝以避免重复计算：

   ```c++
   // 如果不是第一个没有被用过的数的话 就continue
   // 注意:首先 i 要大于 0，因为如果 i = 0 的话，前面肯定没有数了
   
   if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) {
       continue;
   }
   ```

4. 不要忘记递归前和回溯时，对状态进行更新。

以示例中的 `[1,1,2]` 为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：
![图解](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png)


**复杂度分析**

- 时间复杂度：
最差情况所有元素都是唯一的。复杂度和全排列都是 $O(n! * n)$ 对于 $n$ 个元素一共有 $n!$ 中排列方案。而对于每一个答案，我们需要 $O(n)$ 去复制最终放到 `result` 数组。
- 空间复杂度：
$O(n)$ 回溯树的深度取决于我们有多少个元素。