# 459_Repeated Substring Pattern_重复的子字符串

## 解法一：移动匹配

当一个字符串s：`abcabc`，内部由重复的子串组成，那么这个字符串的结构一定是这样的：
![pic1](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104518.png)

也就是由前后相同的子串组成。

那么既然前面有相同的子串，后面有相同的子串，用 $s + s$，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个 `s`，如图：

![pic2](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png)

当然，我们在判断 $s + s$ 拼接的字符串里是否出现一个$s$ 的时候，要刨除 $s + s$ 的首字符和尾字符，这样避免在 $s+s$ 中搜索出原来的 $s$，我们要搜索的是中间拼接出来的 $s$。

时间复杂度: $O(n)$
空间复杂度: $O(1)$

不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串 $(s + s)$ 是否出现过 $s$ 的过程，大家可能直接用 `contains`，`find` 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是 $O(m * n)$，一般库函数实现为 $O(m + n)$）。

## 解法二：KMP

最长相同前后缀和重复子串的关系又有什么关系呢？
- 前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；
- 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串

在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：`abababab` 来举例，`ab` 就是最小重复单位，如图所示：
![pic3](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728205249.png)

- 假设字符串是由重复子串构成，设 $nxt[n]$ 计算出最长重复子串长度，所以最小周期 $t = n - nxt[n]$

- 查看假设是否成立，就判断最小周期 $t$ 不为文本串本身长度，且 `n % t == 0`

时间复杂度: $O(n)$
空间复杂度: $O(n)$ 