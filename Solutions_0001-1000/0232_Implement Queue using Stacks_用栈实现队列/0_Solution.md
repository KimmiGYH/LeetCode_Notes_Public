# 232_Implement Queue using Stacks_用栈实现队列

## 解法一：栈

- 我们用一个栈来存储队列中的元素，另外还需要一个辅助栈，用来辅助实现 $pop()$ 和 $peek()$ 操作。

- 四种操作的实现方式如下：
  - **$push(x)$** – 直接将 $x$ 插入栈顶；
  - **$pop()$** – 即需要弹出栈底元素，我们先将栈底以上的所有元素插入辅助栈中，然后弹出栈底元素，最后再将辅助栈中的元素重新压入当前栈中；
  - **$peek()$** – 返回栈顶元素，同理，我们先将栈底以上的所有元素插入辅助栈中，然后输出栈底元素，最后再将辅助栈中的元素重新压入当前栈中，恢复当前栈原状；
  - **$empty()$** – 返回当前栈是否为空；

**时间复杂度分析：**
- $push(x)$ 和 $emtpy()$ 均只有一次操作，时间复杂度是 $O(1)$；$pop()$ 和 $peek()$ 涉及到 $n$ 次操作，所以时间复杂度是 $O(n)$。

## 解法二：stackIn 和 stackOut

使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈**一个输入栈**，**一个输出栈**，这里要注意输入栈和输出栈的关系。

![pic](https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

【注意】
- 在 `pop` 的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据
- 如果输出栈不为空，则直接从出栈弹出数据就可以了。
- `peek()` 的实现，直接复用了 `pop()`， 要不然，对stackOut 判空的逻辑又要重写一遍。

【Carl贴心建议】
- 在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。

- 这样的项目代码会越来越乱，**一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题**！（踩过坑的人自然懂）

- 工作中如果发现某一个功能自己要经常用，同事们可能也会用到，自己就花点时间把这个功能抽象成一个好用的函数或者工具类，不仅自己方便，也方便了同事们。