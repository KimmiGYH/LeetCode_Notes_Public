# 480_滑动窗口中位数_Sliding Window Median (Hard)

## 解法一：对顶堆思路，$multiset$ 数据结构 $O(nlogk)$

将对顶堆向右旋转 $90°$ 得到水平的结构。
- $upper$ 对应 $right$ 存放较大的数
- $lower$ 对应 $left$ 存放较小的数

1. 定义一个小根堆 `min_heap` 和一个大根堆 `max_heap`，小根堆的堆顶大于等于大根堆的堆顶。
2. 保证小根堆 ($right$) 的大小比大根堆的大小**多** $1$ **或相等**。
3. 按照上述的定义，小根堆的堆顶或者两个堆的堆顶的平均值就是中位数。
4. 添加元素时，若小根堆为空或添加的元素大于等于小根堆堆顶，则添加进小根堆；否则添加到大根堆；
5. 添加后，若两个堆的大小不满足 2 中的要求，则进行调整。
6. 删除元素时，只需要在小根堆或大根堆删除一个等于该元素值的元素即可。
7. 由于此题涉及删除操作，所以堆的容器采用 $multiset$，方便操作。

**算法过程：**
- 用一个 $multiset$ 集合，我们首先将数组的前 $k$ 个数组加入集合中，由于 $multiset$ 自带排序功能，所以我们通过 $k/2$ 能快速地找到指向最中间的数字的迭代器 $mid$；

- 维护了 $left$ 和 $right$ 两个 $multiset$，分别保存有序数组的左半段和右半段的数字，保持 $right$ 的长度大于等于 $left$ 的长度。

- 我们开始遍历数组 $nums$，如果 $i >= k$，说明此时滑动窗口已经满 $k$ 个了
- `int x = nums[i], y = nums[i - k];` $x$ 是加入的数，$y$ 是删除的数

- 先处理插入 $x$ 和删除 $y$ 的操作：
  - 如果 $x$ 大于等于 $right$ 最小值，则将 $x$ 插入进 $right$，否则插入进 $left$；
  - 如果 $y$ 大于等于 $right$ 最小值，则将 $y$ 从 $right$ 中删掉，否则从 $left$ 中删掉；
    - 删的时候不要直接 `erase(y)`，这样会把所有的 $y$ 都删掉
    - 而应该用 `erase(right.find(y))`，这样会只删掉一个 $y$

- 再进行调整操作：
  - 如果左边元素比右边多，那么将左边最大值插到右边去；
  - 如果右边元素比左边多，那么将右边最小值插到左边去。

- 最后我们再计算中位数并加入结果 $res$ 中，根据 $k$ 的奇偶性来分别处理。

**复杂度分析**
- 时间复杂度：由于堆的大小最大为 $k$，在 $multiset$ 中添加或删除元素的时间复杂度为 $O(log⁡k)$，共需要操作 $n$ 次，故总时间复杂度为 $O(nlog⁡k)$。
- 空间复杂度：需要额外 $O(n)$ 的空间存储堆。

## 解法二：对顶堆思路，$priority_queue$ 数据结构 $O(nlogk)$

[题解](https://leetcode-cn.com/problems/sliding-window-median/solution/feng-xian-dui-chong-shuang-dui-dui-ding-hq1dt/)
- 本题考查动态维护数组的中位数。
- 我们思考中位数的性质：如果一个数是中位数，那么在这个数组中，大于中位数的数目和小于中位数的数目，要么相等，要么就相差一。
- 因此，我们采用对顶堆的做法，控制所有小于等于中位数的数字放到一个堆中，控制所有比中位数大的数字放到另一个堆中，并且保证两个堆的数目相差小于等于 $1$。这样就可以保证每一次查询中位数的时候，答案一定出于两个堆的堆顶元素之一。
- 因此选定数据结构：优先队列。因为优先队列采用的是堆结构，正好符合我们的需求。我们将所有小于等于中位数的元素放到 $lower$ 堆中（是一个大顶堆），将所有大于中位数的元素放到 $upper$ 堆中（是一个小顶堆）。

初始化方法如下：
- 将前 $k$ 个元素全部插入到 $upper$ 堆中。从 $upper$ 堆中弹出 $k/2$ 个元素到 $lower$ 堆中。
- 这样，当 $k$ 为奇数，则 $upper$ 堆元素比 $lower$ 堆元素多 $1$；当 $k$ 为偶数，两个堆元素相等。

取中位数的操作：
- 我们的插入操作可以保证每次优先插入到 $upper$ 堆中，因此 $upper$ 堆中的元素个数大于等于 $lower$ 堆的元素个数。
- 当 $k$ 为奇数时候，中位数是元素数量较多的 $upper$ 堆 堆顶元素。
- 当 $k$ 为偶数时候，中位数是 $lower$ 堆和 $upper$ 堆的堆顶元素平均值。

窗口滑动过程中的操作：
- 假定在上一次滑动之后，已经有 $lower$ 堆和 $upper$ 堆元素数目相差小于等于 $1$
- 设置当前的滑动时，$balance = 0$。$balance$ 表示因本次窗口滑动导致 $lower$ 堆元素数目与 $upper$ 堆元素个数差值的增量。

- 添加进来窗口右侧的元素，让 `x = nums[i]`。
  - 如果 `x >= upper.top()`，就应该让这个元素放到 $upper$ 堆里面，`balance++`；
  - 否则，放到 $lower$ 堆里，`balance--`。
- 删除窗口左侧的元素，让被删掉的元素为 `y = nums[i - k]`。
  - 由于堆无法直接删除掉某个指定元素，先欠下这个账，等某次元素出现在堆顶的时候，再删除他。$hash$ 记录这个元素欠账的个数。`hash[y]++;`
  - 虽然没有真的在堆数据结构中删除窗口最左侧的元素，但是在我们的心中已经删掉它了。堆两侧的平衡性发生了变化。
  - 如果 `y >= upper.top()`，就说明删掉的元素在 $upper$ 堆中，我们让 `balance--`；
  - 否则，就说明删掉的元素在 $lower$ 堆中，让 `balance++`；

- 调整完了，现在该欠债还钱了。不能让那些早该删除的元素涉及到中位数的运算。
  - 分别检查两边的堆顶元素，如果堆顶元素欠着债，则弹出堆顶元素，直到堆顶元素没有欠债为止。有朋友问了：堆顶下面也有欠债的怎么办呢？我们之前说过，取中位数的时候只与堆顶元素有关，至于那些堆顶下面欠着债的，欠着就欠着吧，等他们到堆顶的时候再弹出去就好了。

- 最后，添加中位数即可。





