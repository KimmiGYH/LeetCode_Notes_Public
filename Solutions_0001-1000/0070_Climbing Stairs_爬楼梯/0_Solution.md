# 70. Climbing Stairs

我们用 f(x)f(x) 表示爬到第 xx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：

```
f(x) = f(x - 1) + f(x - 2)
```

- 一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 `O(n)`。

- 简单的 DP，经典的爬楼梯问题。⼀个楼梯可以由 `n-1` 和 `n-2` 的楼梯爬上来。
- 这⼀题求解的值就是斐波那契数列。  





## 方法一：记忆化搜索/递归

```c++
#include <vector>
using namespace std;

vector<int> memo;

int fib( int n ) {
    
    if ( n == 0 )
        return 0;
    
    if ( n == 1 )
        return 1;
    
    if ( memo[n] == -1 )
        memo[n] = fib(n-1) + fib(n-2);
    
    return memo[n];
}
```





## 方法二：动态规划迭代

```c++
#include <vector>
using namespace std;

int fib( int n ) {

    vector<int> memo(n+1, -1);

    memo[0] = 0;
    memo[1] = 1;
    for (int i = 2; i <= n; i++)
        memo[i] = memo[i-1] + memo[i-2];
    
    return memo[n];
}
```



## 方法三：Fibonacci滚动数组

为了优化空间复杂度，我们可以不用保存 `f(x - 2)` 之前的项，我们只用三个变量来维护 `f(x)`、`f(x - 1)` 和 `f(x - 2)`，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 `O(1)`。

```c++
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i <= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
};
```

- 时间复杂度：循环执行 `n` 次，每次花费常数的时间代价，故渐进时间复杂度为 `O(n)`。
- 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 `O(1)`。





## 总结：

这里形成的数列正好是斐波那契数列，答案要求的 `f(n)` 即是斐波那契数列的第 `n` 项（下标从 `0` 开始）。我们来总结一下斐波那契数列第 `n` 项的求解方法：

- `n` 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 O(2^n^)，存在很多冗余计算。

- 一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 `O(n)`。
- 为了优化空间复杂度，我们可以不用保存 `f(x - 2)` 之前的项，我们只用三个变量来维护 `f(x)`、`f(x - 1)`和 `f(x - 2)`，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 `O(1)`。
- 随着 `n` 的不断增大 `O(n)` 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 `O(log n)`。
- 我们也可以把 `n` 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



