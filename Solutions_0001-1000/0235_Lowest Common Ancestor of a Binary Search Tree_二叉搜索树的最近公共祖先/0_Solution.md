# 235. Lowest Common Ancestor of a Binary Search Tree_二叉搜索树的最近公共祖先

## 解法一：利用BST性质的递归 $O(h)$

由于这是一棵二叉查找树，我们可以利用二叉查找树的性质来从根结点开始寻找。

- 首先根结点必定是候选公共祖先，接着如果 `p` 和 `q` 同时出现在左子树，则我们往左儿子移动；

- 如果 `p` 和 `q` 同时出现在右子树，则我们往右儿子移动；

- 若发现不满足 2 中的两个条件，则停止寻找，当前结点就是最近公共祖先。

**要点解释：**

- 只要从上到下去遍历，遇到 `cur` 节点是数值在 `[p, q]` 区间中则一定可以说明该节点 `cur` 就是 `q` 和 `p` 的公共祖先。 那问题来了，一定是 **最近公共祖先** 吗？

- 如图，我们从根节点搜索，第一次遇到 `cur` 节点是数值在 `[p, q]` 区间中，即 节点 `5`，此时可以说明 `p` 和 `q` 一定分别存在于 节点 `5` 的左子树，和右子树中。
![图解](https://code-thinking-1253855093.file.myqcloud.com/pics/20220926164214.png)

- 此时节点 `5` 是不是最近公共祖先？ 如果 从节点 `5` 继续向左遍历，那么将错过成为 `q` 的祖先， 如果从节点 `5` 继续向右遍历则错过成为 `p` 的祖先。

- 所以当我们从上向下去递归遍历，第一次遇到 `root` 节点是数值在 `[p, q]` 区间中，那么 `root` 就是 `p` 和 `q` 的最近公共祖先。

- 理解这一点，本题就很好解了。

##### 时间复杂度

每次都会降低一层，故最坏时间复杂度也就是树的高度 $O(h)$。

## 解法二：暴力递归 $O(n)$

解法跟 236.求普通二叉树中的公共祖先一致

## 解法三：迭代

思路跟递归类似，但写成了迭代的形式
