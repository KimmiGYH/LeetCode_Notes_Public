# 202_Happy Number_快乐数

## 解法一：哈希集合 $O(\log n)$

- 题目大意：在求快乐数的过程中，无限循环里是否有 $1$。
- 疑惑：为什么无限循环一定是有环？为什么不会一直延伸下去值越来越大接近无穷大？
- 回答：猜测有三种可能：
  - 1) 最终会得到 $1$
  - 2) 最终会进入循环（环）
  - 3) 值会越来越大，最后接近无穷大

- 由于 $int$ 最大值为 $2^{31} - 1$，等于 $2147483647$，相当于 $2.1$ 亿。
- 这个最大数的位数是十位，而十位的最大值为 $9999999999$，它的下一个数为 $81*10=810$。
- 这意味着从 $0$ 到 $810$ 这 $811$ 次操作后，根据鸽巢原理，第 $812$ 次操作必然会产生环，我们只需看这个环里是否存在 $1 即可。
- 所以算法会在 $812$ 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 $1$。但它不会无限期地进行下去，所以我们排除第三种选择。

算法过程：
1. 给一个数字 $n$，它的下一个数字是什么？做数位分离，求平方和。
2. 判断我们是否进入了一个循环，可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。
   - 如果它不在哈希集合中，我们应该添加它
   - 如果它在哈希集合中，这意味着我们处于一个循环中
3. 我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 $O(1)$ 的时间，而对于其他数据结构，则需要 $O(n)$ 的时间。选择正确的数据结构是解决这些问题的关键部分。

**复杂度分析**
- 时间复杂度：$O(811 + \log n + \log\log n + \log\log\log n)...= O(\log n)$。
  - 要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。
  - 我们在上面确定，一旦一个数字低于 $811$，它就不可能回到 $811$ 以上。因此，我们就可以用 $811$ 以下最长循环的长度来代替 $811$，不过，因为常数无论如何都无关紧要，所以我们不会担心它。
  - 对于高于 $811$ 的 $n$，我们需要考虑循环中每个数高于 $811$ 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 $O(logn)+O(loglogn)+O(logloglogn)...$。幸运的是，$O(\log n)$ 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于 $\log n$），所以我们可以忽略它们。

- 空间复杂度：$O(\log n)$。
  - 与时间复杂度密切相关的是衡量我们放入哈希集合中的数字以及它们有多大的指标。
  - 对于足够大的 $n$，大部分空间将由 $n$ 本身占用。
  - 我们可以很容易地优化到 $O(811) = O(1)$，方法是只保存集合中小于 $811$ 的数字，因为对于较高的数字，无论如何都不可能返回到它们。

## 解法二： Floyd's Cycle + 快慢指针 $O(1)$

(快慢指针) $O(1)$
- 从 $0-810$ 一共只有 $811$ 个数，如果操作了 $812$ 步，必然有一个数是在环里
- 这道题其实就是包装后的环形链表，其中
  - 慢指针就是每次把数字各位求一次平方和
  - 快指针就是每次把数字各位求两次平方和
- 有两种情况
  - 是快乐数：最后两个指针都会变成 $1$，重合在一起
  - 不是快乐数：相当于一个环，快慢指针总会在某个数处相遇
- 即：不管是不是快乐数，快慢指针最终都会汇聚到一个数上，我们只需要判断这个数是不是 $1$ 即可

**复杂度分析**

- 时间复杂度：$O(1)$
  - 把 $sum$ 的值看成是一个链表，那么问题转换成链表是否有环。 用快慢指针判断链表中是否有环，$slow$ 和 $fast$ 最后一定会收敛到某个数字。
- 空间复杂度：$O(1)$，
  - 对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。
