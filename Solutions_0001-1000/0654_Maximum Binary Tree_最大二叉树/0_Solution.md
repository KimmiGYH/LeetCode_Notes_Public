# 654_Maximum Binary Tree_最大二叉树

## 解法一：DFS 递归

![图解](https://code-thinking.cdn.bcebos.com/gifs/654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.gif)


构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。

- 确定递归函数的参数和返回值

    参数传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。

- 确定终止条件

    题目中说了输入的数组大小一定是大于等于 $1$ 的，所以我们不用考虑小于 $1$ 的情况，那么当递归遍历的时候，如果传入的数组大小为 $1$，说明遍历到了叶子节点了。

    那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是 $1$ 的时候，构造了一个新的节点，并返回。

- 确定单层递归的逻辑

这里有三步工作

1. 先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。

2. 最大值所在的下标左区间 构造左子树
这里要判断 `maxValueIndex > 0`，因为要保证左区间至少有一个数值。

3. 最大值所在的下标右区间 构造右子树
判断 `maxValueIndex < nums.size() - 1`，确保右区间至少有一个数值。

这一版代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的 `vector`（也就是数组），但逻辑比较清晰。

**时间复杂度**

- 最坏情况下，每次寻找的最大值都在当前区间的最左边，即数组是有序数组，这样就会有 $n$ 层递归，总共需要 $n + (n - 1) + (n - 2) + … + 1$ 次计算，所以时间复杂度是 $O(n2)$


## 解法二：单调栈

- 把最后构造树的过程放进单调栈求解。
- 如果数值比栈顶元素大，则将栈顶元素作为新建的 $node$ 的左孩子，直到找到峰顶
- 此时栈底为峰顶元素，将右侧的节点新建 $node$ 作为栈顶元素的右孩子，并将右孩子加入栈中
- 如遇到更大的节点如 $5$，此时插入该节点，节点 $5$ 左孩子为 $0$，将 $0$ pop掉；将峰顶元素的右孩子设为 $5$，将 $5$ 加入栈中
- 清空单调栈，剩下的就是根节点/最大的节点

**时间复杂度**
- $O(n)$