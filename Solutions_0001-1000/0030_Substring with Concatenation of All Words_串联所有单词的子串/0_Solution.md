# 30_Substring with Concatenation of All Words_串联所有单词的子串

## 解法一：双指针+滑动窗口 $O(n*m)$

- 先考虑一共要枚举哪些情况？
    ```
    n: s.size()
    m: words.size()
    w: words[0].size()
    ```
- 可以把所有的起始位置做分类，按照所有起始位置对于 $w$ 的余数来分类
    ```
    |-----------------------------------------|
    0      w      2w      3w      ...
    1      w+1    2w+1    3w+1    ...
    ......
    w-1   2w-1    3w-1    4w-1    ...
    ```
- 问题变成：在 $s$ 中找到连续的 $m$ 个单词，恰好是 $words$ 给定的 $m$ 个元素，使用滑动窗口
- 用长度为 $m$ 的滑动窗口来维护所有长度为 $m$ 的连续子段（窗口里所有的单词也存到哈希表中），每次窗口往后移动一位都会增加一个单词，删除一个旧的单词
- 判断**当前哈希表**维护的集合，与 $words$ 对应的**给定哈希表**集合 是否一致？如果元素数量一一对应，那就说明 $s$ 中连续 $m$ 个单词就是  $words$ 给定的 $m$ 个单词
- 如何判断两个哈希表集合相等？除了维护哈希表之外，还要用个变量 $cnt$ 去存当前哈希表集合中有多少个**有效**单词是给定的集合里的。有两层含义：种类、数量 都一致。

**复杂度分析**
- 时间复杂度：$O(n*w)$
  - 每次扫描一组，两个指针均最多移动 $w = \dfrac{n}{m}$ 次
  - 虽然哈希表操作是 $O(1)$，但每组每次移动时哈希表操作的复杂度其实是这个单词的长度 $O(w)$
  - 所以每组时间复杂度为 $O(\dfrac{n}{m}*w) = O(w^{2})$
  - 一共有 $m$ 组，所以整体复杂度是 $O(n*w)$

## 解法二：字符串哈希 $O(n)$

- 通过字符串哈希，将哈希表操作的复杂度从 $O(w)$ 降为 $O(1)$
- 做的时候为了统一下标，需要做以下几步：
  - 将 $s$ 前面加上空格，即 `s = ' ' + s;` 这样就能从 $i = 1$ 来枚举 $s$ 中的字符
  - 对 $words$ 做字符串哈希时，直接遍历，搞个变量 $hash$ 存进哈希表中即可，无需另外开数组
  - 按照所有起始位置对于 $w$ 的余数来分类时，下标这样设置：
    - 外层：`for (int i = 1; i <= w; i++) {`
    - 内层：`for (int j = i; j + w <= n + 1; j += w) {`
    - 对比原来的下标：
    - 原来外层：`for (int i = 0; i < w; i++) {`
    - 原来内层：`for (int j = i; j + w <= n; j += w) {`
- 通过 $get()$ 函数取哈希值时，$R$ 下标要写成


