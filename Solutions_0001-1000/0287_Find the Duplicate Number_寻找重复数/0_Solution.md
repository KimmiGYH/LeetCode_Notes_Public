# 287_Find the Duplicate Number_寻找重复数 (Medium)

## 解法一：Floyd's Cycle 龟兔赛跑 $O(n)$

- 本解法 lc142_Linked List Cycle II_环形链表Ⅱ 相同方法。

- 由于没有任何一个位置存的是 $0$，而且 $0~n$ 每个点都有出边，所以从 $0$ 开始走一定能往下继续走，并且必然会在某个时刻走到之前已经走过的点，存在环，且 $0$ 一定不在环里。

## 解法二：(分治，抽屉原理/鸽巢原理) $O(nlogn)$

道题目主要应用了抽屉原理和分治的思想。

> 抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。

- 用在这个题目中就是，一共有 $n+1$ 个数，每个数的取值范围是 $1$ 到 $n$，所以至少会有一个数出现两次。

- 然后我们采用分治的思想，将每个数的取值的区间 $[1, n]$ 划分成 $[1, n/2]$ 和$[n/2+1, n]$ 两个子区间，然后分别统计两个区间中数的个数。
注意这里的区间是指 **数的取值范围**，而不是 **数组下标**。

- 划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。
这个可以用反证法来说明：如果两个区间中数的个数都小于等于区间长度，那么整个区间中数的个数就小于等于 $n$，和有 $n+1$ 个数矛盾。

- 因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。

- 依次类推，每次我们可以把区间长度缩小一半，直到区间长度为 $1$ 时，我们就找到了答案。

**复杂度分析**：

- 时间复杂度：每次会将区间长度缩小一半，一共会缩小 $O(logn)$ 次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是 $O(n)$。所以总时间复杂度是 $O(nlogn)$。
- 空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是 $O(1)$。

## 解法三：位操作 Bit Manipulation

- 这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 $1$ 还是 $0$ 就可以按位还原出重复的数是什么。

- 考虑到第 $i$ 位，我们记 $nums$ 数组中二进制展开后第 $i$ 位为 $1$ 的数有 $x$ 个，数字 $[1,n]$ 这 $n$ 个数二进制展开后第 $i$ 位为 $1$ 的数有 $y$ 个，那么重复的数第 $i$ 位为 $1$ 当且仅当 $x > y$。

- 仍然以示例1 为例，如下的表格列出了每个数字二进制下每一位是 $1$ 还是 $0$ 以及对应位的 $x$ 和 $y$ 是多少：



|         | 1    | 3    | 4    | 2    | 2    | x    | y    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 第 0 位 | 1    | 1    | 0    | 0    | 0    | 2    | 2    |
| 第 1 位 | 0    | 1    | 0    | 1    | 1    | 3    | 2    |
| 第 2 位 | 0    | 0    | 1    | 0    | 0    | 1    | 1    |

那么按之前说的我们发现只有第 $1$ 位 $x > y$，所以按位还原后 $target = (010)_{2}  = (2)_{10}$，符合答案。

## 解法四：换成相反数的做法

- 把当前数字看作下标
- 把对应下标处的数字先换成相反数
- 因为有重读的数字，那肯定会多次取到那个下标
- 所以一发现这个数字已经被取反了，证明这个下标重复了
