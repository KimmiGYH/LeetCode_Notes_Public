# 12_Integer to Roman_整数转罗马数字

## 解法一：$pair$ + 哈希思维 $O(1)$

|      |        |        |        |    表 | 格    |       |       |        |       |
| ---- | ------ | ------ | ------ | ----- | ----- | ----- | ----- | ------ | ----- |
| 个位 | $1$    | $2$    | $3$    | $4$   | $5$   | $6$   | $7$   | $8$    | $9$   |
|      | $I$    | $II$   | $III$  | $IV$  | $V$   | $VI$  | $VII$ | $VIII$ | $IX$  |
| 十位 | $10$   | $20$   | $30$   | $40$  | $50$  | $60$  | $70$  | $80$   | $90$  |
|      | $X$    | $XX$   | $XXX$  | $XL$  | $L$   | $LX$  | $LXX$ | $LXXX$ | $XC$  |
| 百位 | $100$  | $200$  | $300$  | $400$ | $500$ | $600$ | $700$ | $800$  | $900$ |
|      | $C$    | $CC$   | $CCC$  | $CD$  | $D$   | $DC$  | $DCC$ | $DCCC$ | $CM$  |
| 千位 | $1000$ | $2000$ | $3000$ |       |       |       |       |        |       |
|      | $M$    | $MM$   | $MMM$  |       |       |       |       |        |       |

- 选取红框内关键数值符号对，建立一个数值-符号对的列表 $table$，可用 $pair$ 放进 $vector$ 中来存储
- 遍历时从大到小遍历
- 若当前数值 $value$ 不超过 $num$，则从 $num$ 中不断减去 $value$，直至 $num$ 小于 $value$，然后遍历下一个数值-符号对

**复杂度分析**
- 时间复杂度：$O(1)$。
  - 由于 $table$ 长度是固定的，且这 $13$ 字符中的每个字符的出现次数均不会超过 $3$，因此循环次数有一个确定的上限。
  - 对于本题给出的数据范围，循环次数不会超过 $15$ 次。
- 空间复杂度：$O(1)$。

## 解法二：硬编码数字

- 回顾前言中列出的这 $13$ 个符号，可以发现：

  - 千位数字只能由 $\texttt{M}$ 表示；
  - 百位数字只能由 $\texttt{C}$，$\texttt{CD}$，$\texttt{D}$ 和 $\texttt{CM}$ 表示；
  - 十位数字只能由 $\texttt{X}$，$\texttt{XL}$，$\texttt{L}$ 和 $\texttt{XC}$ 表示；
  - 个位数字只能由 $\texttt{I}$，$\texttt{IV}$，$\texttt{V}$ 和 $\texttt{IX}$ 表示。

- 这恰好把这 $13$ 个符号分为四组，且组与组之间没有公共的符号。因此，整数 $\textit{num}$ 的十进制表示中的每一个数字都是可以单独处理的。

- 进一步地，我们可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 $0 $对应的是空字符串。

![硬编码表](https://assets.leetcode-cn.com/solution-static/12/3.png)

- 利用模运算和除法运算，我们可以得到 $\textit{num}$ 每个位上的数字：
    ```cpp
    thousands_digit = num / 1000
    hundreds_digit = (num % 1000) / 100
    tens_digit = (num % 100) / 10
    ones_digit = num % 10
    ```

- 最后，根据 $\textit{num}$ 每个位上的数字，在硬编码表中查找对应的罗马字符，并将结果拼接在一起，即为 $\textit{num}$ 对应的罗马数字。

**复杂度分析**
- 时间复杂度：$O(1)$。计算量与输入数字的大小无关。
- 空间复杂度：$O(1)$。

