# 53_Maximum Subarray_最大子序和 (Easy)


## 解法一：贪心

**贪心贪的是哪里呢？**

如果 `-2 1` 在一起，计算起点的时候，一定是从 `1` 开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”。

*局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。*

从代码角度上来讲：遍历 `nums`，从头开始用 `sum` 累积，如果 `sum` 一旦加上 `nums[i]` 变为负数，那么就应该从 `nums[i+1]` 开始从 $0$ 累积 `sum` 了，因为已经变为负数的 `sum`，只会拖累总和。

![图解](https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif)

区间的终止位置，其实就是如果 `sum` 取到最大值了，及时记录下来了。例如如下代码：

```cpp
if (sum > result) result = sum;
```

##### 复杂度分析：

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

## 解法二：动态规划 $O(n)$

- 状态表示：$f(i)$ 表示所有以 $nums[i]$ 结尾的区间中的最大和是多少。

- 递推关系：$f(i) = max(nums[i], f(i-1) + nums[i]) = nums[i] + max(0, f(i-1))$。

  - 用变量 `last` 来记录 $f(i-1)$，得 $f(i) = nums[i] + max(0, last)$，就可以算出来 $f(i)$。之后再把 `last` (即 $f(i-1)$) 更新成 $f(i)$。

**时间复杂度：**

- 状态数为 $O(n)$，转移时间为 $O(1)$，故总时间复杂度为 $O(n)$。

**空间复杂度：**

- 需要额外 $O(n)$ 的空间存储状态。
- 可以通过一个变量 `last` 来替代数组**将空间复杂度优化到常数**。
