# 77. Combinations_组合 (Medium)

## 解法一： DFS + Backtracking 深度优先搜索 + 回溯  $O(C_{n}^{k} * k)$

![题意](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。

第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。**

**图中可以发现 $n$ 相当于树的宽度，$k$ 相当于树的深度。**



![图解](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出 $for$ 循环用来横向遍历，递归的过程是纵向遍历。

$for$ 循环每次从 `startIndex` 开始遍历，然后用 `path` 保存取到的节点 `i`。

```cpp
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i); // 处理节点
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop_back(); // 回溯，撤销处理的节点
}
```

可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。


### 以前写的：

- 深度优先搜索，一共枚举 $k$ 层，$k$ 表示当前还需要选几个数。

- 由于这道题要求组合数，不考虑数的顺序，所以我们需要再记录一个值 `startIndex`，表示当前数可以从第几个数开始选，来保证所选的数递增。

    `dfs(n, k, startIndex)`
- 比如前面已经选到 $5$ 了，下次选的时候应从 $6$ 开始选。$k$ 表示当前还可以选几个数。
    `dfs(n, k - 1, start + 1)`
当然也可以用 `if (k == path.size())` 这样的条件来判断，这时 $k$ 表示题意里的意思


**时间复杂度分析：**

- 一共有 $C_{n}^{k}$ 个方案，另外记录每个方案时还需要  $O(k)$ 的时间，所以时间复杂度是是 $O(C_{n}^{k} * k)$。


## 解法二：回溯剪枝
```cpp
for (int i = start; i <= n+1 - (k - path.size()); i++)
```

- `path.size()` ： 已经找的个数
- `k-path.size()` ：还需找的个数
- `【x, n】`的数组长度起码应该是 `k - path.size()` 才有继续搜索的可能， 那么就有 `n-x+1 = k-path.size()`， 解方程得 `x = n+1 - (k-path.size())`, 而且这个 `x` 是可以作为起点往下搜的 也就是 `for(i = s; i <= x; i++)` 这里的 `x` 是可以取到的
