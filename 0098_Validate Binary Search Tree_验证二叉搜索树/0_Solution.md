# 98. Validate Binary Search Tree_验证二叉搜索树 (Medium)



## 解法一：按定义

**(深度优先遍历) $O(n)$**

深度优先遍历整棵子树。

遍历时，需要向上传递当前子树中的**最小值**和**最大值**，这里可以用 C++ 中的引用来传递。

对于当前节点，我们先遍历它的左子树，判断左子树是否合法，同时判断左子树的最大值是否小于当前节点的值；

然后遍历右子树，判断右子树是否合法，同时判断右子树的最小值是否大于当前节点的值。

如果条件均满足，说明以当前节点为根的子树是一棵合法的二叉搜索树，返回 `true`。

##### 时间复杂度分析

树中每个节点仅被遍历一遍，所以时间复杂度是 $O(n)$。



## 解法二：判断中序遍历是否是有序的

从上到下判断，在往下遍历子树的过程中，根据父节点的信息记录并更新子树的值的大小范围

1. 如果当前结点超过了当前的大小范围，则返回 `false`

2. 否则递归遍历左子树，将左子树的最大值的范围更新为当前结点的值；递归遍历右子树，将右子树的最小值的范围更新为当前结点的值。

##### 时间复杂度分析

$O(N)$，每个结点只遍历一次